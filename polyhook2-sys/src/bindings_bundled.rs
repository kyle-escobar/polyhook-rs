/* automatically generated by rust-bindgen 0.60.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        pub type equal_to_first_argument_type = u8;
        pub type equal_to_second_argument_type = u8;
        pub type equal_to_result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator__From_primary = u8;
        pub type allocator_value_type = u8;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view {
            pub _address: u8,
        }
        pub type basic_string_view_traits_type = u8;
        pub type basic_string_view_value_type = u8;
        pub type basic_string_view_pointer = u8;
        pub type basic_string_view_const_pointer = u8;
        pub type basic_string_view_reference = u8;
        pub type basic_string_view_const_reference = u8;
        pub type basic_string_view_const_iterator = u8;
        pub type basic_string_view_iterator = u8;
        pub type basic_string_view_const_reverse_iterator = u8;
        pub type basic_string_view_reverse_iterator = u8;
        pub type basic_string_view_size_type = u64;
        pub type basic_string_view_difference_type = u64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Alty = u8;
        pub type basic_string__Alty_traits = u8;
        pub type basic_string__Scary_val = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_difference_type = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        pub type basic_string__Is_elem_cptr = u8;
        pub type basic_string__Is_string_view_ish = u8;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct logic_error {
            pub _bindgen_opaque_blob: [u64; 3usize],
        }
        pub type logic_error__Mybase = [u64; 3usize];
        pub type atomic_long = u32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr__Mybase = u8;
        pub type shared_ptr_weak_type = u8;
        pub mod experimental {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod filesystem {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Alty = u8;
        pub type vector__Alty_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_difference_type = u8;
        pub type vector__Scary_val = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub type unordered_map__Mytraits = u8;
        pub type unordered_map__Mybase = u8;
        pub type unordered_map__Alnode = u8;
        pub type unordered_map__Alnode_traits = u8;
        pub type unordered_map__Nodeptr = u8;
        pub type unordered_map__Key_compare = u8;
        pub type unordered_map_hasher = u8;
        pub type unordered_map_key_type = u8;
        pub type unordered_map_mapped_type = u8;
        pub type unordered_map_key_equal = u8;
        pub type unordered_map_value_type = u8;
        pub type unordered_map_allocator_type = u8;
        pub type unordered_map_size_type = u8;
        pub type unordered_map_difference_type = u8;
        pub type unordered_map_pointer = u8;
        pub type unordered_map_const_pointer = u8;
        pub type unordered_map_reference = u8;
        pub type unordered_map_const_reference = u8;
        pub type unordered_map_iterator = u8;
        pub type unordered_map_const_iterator = u8;
        pub type unordered_map_local_iterator = u8;
        pub type unordered_map_const_local_iterator = u8;
        pub type unordered_map_insert_return_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_set {
            pub _address: u8,
        }
        pub type unordered_set__Mytraits = u8;
        pub type unordered_set__Mybase = u8;
        pub type unordered_set__Alnode = u8;
        pub type unordered_set__Alnode_traits = u8;
        pub type unordered_set__Key_compare = u8;
        pub type unordered_set_hasher = u8;
        pub type unordered_set_key_type = u8;
        pub type unordered_set_key_equal = u8;
        pub type unordered_set_value_type = u8;
        pub type unordered_set_allocator_type = u8;
        pub type unordered_set_size_type = u8;
        pub type unordered_set_difference_type = u8;
        pub type unordered_set_pointer = u8;
        pub type unordered_set_const_pointer = u8;
        pub type unordered_set_reference = u8;
        pub type unordered_set_const_reference = u8;
        pub type unordered_set_iterator = u8;
        pub type unordered_set_const_iterator = u8;
        pub type unordered_set_local_iterator = u8;
        pub type unordered_set_const_local_iterator = u8;
        pub type unordered_set_insert_return_type = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct mutex {
            pub _bindgen_opaque_blob: [u64; 10usize],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        pub type function__Mybase = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional__Mybase = u8;
        pub type optional_value_type = u8;
        pub type optional__AllowDirectConversion = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional__AllowUnwrapping {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional__AllowUnwrappingAssignment {
            pub _address: u8,
        }
    }
    pub type csh = usize;
    pub const arm_shifter_ARM_SFT_INVALID: root::arm_shifter = 0;
    #[doc = "< shift with immediate const"]
    pub const arm_shifter_ARM_SFT_ASR: root::arm_shifter = 1;
    #[doc = "< shift with immediate const"]
    pub const arm_shifter_ARM_SFT_LSL: root::arm_shifter = 2;
    #[doc = "< shift with immediate const"]
    pub const arm_shifter_ARM_SFT_LSR: root::arm_shifter = 3;
    #[doc = "< shift with immediate const"]
    pub const arm_shifter_ARM_SFT_ROR: root::arm_shifter = 4;
    #[doc = "< shift with immediate const"]
    pub const arm_shifter_ARM_SFT_RRX: root::arm_shifter = 5;
    #[doc = "< shift with register"]
    pub const arm_shifter_ARM_SFT_ASR_REG: root::arm_shifter = 6;
    #[doc = "< shift with register"]
    pub const arm_shifter_ARM_SFT_LSL_REG: root::arm_shifter = 7;
    #[doc = "< shift with register"]
    pub const arm_shifter_ARM_SFT_LSR_REG: root::arm_shifter = 8;
    #[doc = "< shift with register"]
    pub const arm_shifter_ARM_SFT_ROR_REG: root::arm_shifter = 9;
    #[doc = "< shift with register"]
    pub const arm_shifter_ARM_SFT_RRX_REG: root::arm_shifter = 10;
    #[doc = " ARM shift type"]
    pub type arm_shifter = cty::c_int;
    pub const arm_cc_ARM_CC_INVALID: root::arm_cc = 0;
    #[doc = "< Equal                      Equal"]
    pub const arm_cc_ARM_CC_EQ: root::arm_cc = 1;
    #[doc = "< Not equal                  Not equal, or unordered"]
    pub const arm_cc_ARM_CC_NE: root::arm_cc = 2;
    #[doc = "< Carry set                  >, ==, or unordered"]
    pub const arm_cc_ARM_CC_HS: root::arm_cc = 3;
    #[doc = "< Carry clear                Less than"]
    pub const arm_cc_ARM_CC_LO: root::arm_cc = 4;
    #[doc = "< Minus, negative            Less than"]
    pub const arm_cc_ARM_CC_MI: root::arm_cc = 5;
    #[doc = "< Plus, positive or zero     >, ==, or unordered"]
    pub const arm_cc_ARM_CC_PL: root::arm_cc = 6;
    #[doc = "< Overflow                   Unordered"]
    pub const arm_cc_ARM_CC_VS: root::arm_cc = 7;
    #[doc = "< No overflow                Not unordered"]
    pub const arm_cc_ARM_CC_VC: root::arm_cc = 8;
    #[doc = "< Unsigned higher            Greater than, or unordered"]
    pub const arm_cc_ARM_CC_HI: root::arm_cc = 9;
    #[doc = "< Unsigned lower or same     Less than or equal"]
    pub const arm_cc_ARM_CC_LS: root::arm_cc = 10;
    #[doc = "< Greater than or equal      Greater than or equal"]
    pub const arm_cc_ARM_CC_GE: root::arm_cc = 11;
    #[doc = "< Less than                  Less than, or unordered"]
    pub const arm_cc_ARM_CC_LT: root::arm_cc = 12;
    #[doc = "< Greater than               Greater than"]
    pub const arm_cc_ARM_CC_GT: root::arm_cc = 13;
    #[doc = "< Less than or equal         <, ==, or unordered"]
    pub const arm_cc_ARM_CC_LE: root::arm_cc = 14;
    #[doc = "< Always (unconditional)     Always (unconditional)"]
    pub const arm_cc_ARM_CC_AL: root::arm_cc = 15;
    #[doc = " ARM condition code"]
    pub type arm_cc = cty::c_int;
    pub const arm_mem_barrier_ARM_MB_INVALID: root::arm_mem_barrier = 0;
    pub const arm_mem_barrier_ARM_MB_RESERVED_0: root::arm_mem_barrier = 1;
    pub const arm_mem_barrier_ARM_MB_OSHLD: root::arm_mem_barrier = 2;
    pub const arm_mem_barrier_ARM_MB_OSHST: root::arm_mem_barrier = 3;
    pub const arm_mem_barrier_ARM_MB_OSH: root::arm_mem_barrier = 4;
    pub const arm_mem_barrier_ARM_MB_RESERVED_4: root::arm_mem_barrier = 5;
    pub const arm_mem_barrier_ARM_MB_NSHLD: root::arm_mem_barrier = 6;
    pub const arm_mem_barrier_ARM_MB_NSHST: root::arm_mem_barrier = 7;
    pub const arm_mem_barrier_ARM_MB_NSH: root::arm_mem_barrier = 8;
    pub const arm_mem_barrier_ARM_MB_RESERVED_8: root::arm_mem_barrier = 9;
    pub const arm_mem_barrier_ARM_MB_ISHLD: root::arm_mem_barrier = 10;
    pub const arm_mem_barrier_ARM_MB_ISHST: root::arm_mem_barrier = 11;
    pub const arm_mem_barrier_ARM_MB_ISH: root::arm_mem_barrier = 12;
    pub const arm_mem_barrier_ARM_MB_RESERVED_12: root::arm_mem_barrier = 13;
    pub const arm_mem_barrier_ARM_MB_LD: root::arm_mem_barrier = 14;
    pub const arm_mem_barrier_ARM_MB_ST: root::arm_mem_barrier = 15;
    pub const arm_mem_barrier_ARM_MB_SY: root::arm_mem_barrier = 16;
    #[doc = " The memory barrier constants map directly to the 4-bit encoding of"]
    #[doc = " the option field for Memory Barrier operations."]
    pub type arm_mem_barrier = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const arm_op_type_ARM_OP_INVALID: root::arm_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const arm_op_type_ARM_OP_REG: root::arm_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const arm_op_type_ARM_OP_IMM: root::arm_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const arm_op_type_ARM_OP_MEM: root::arm_op_type = 3;
    #[doc = "< = CS_OP_FP (Floating-Point operand)."]
    pub const arm_op_type_ARM_OP_FP: root::arm_op_type = 4;
    #[doc = "< C-Immediate (coprocessor registers)"]
    pub const arm_op_type_ARM_OP_CIMM: root::arm_op_type = 64;
    #[doc = "< P-Immediate (coprocessor registers)"]
    pub const arm_op_type_ARM_OP_PIMM: root::arm_op_type = 65;
    #[doc = "< operand for SETEND instruction"]
    pub const arm_op_type_ARM_OP_SETEND: root::arm_op_type = 66;
    #[doc = "< MSR/MRS special register operand"]
    pub const arm_op_type_ARM_OP_SYSREG: root::arm_op_type = 67;
    #[doc = " Operand type for instruction's operands"]
    pub type arm_op_type = cty::c_int;
    #[doc = "< Uninitialized."]
    pub const arm_setend_type_ARM_SETEND_INVALID: root::arm_setend_type = 0;
    #[doc = "< BE operand."]
    pub const arm_setend_type_ARM_SETEND_BE: root::arm_setend_type = 1;
    #[doc = "< LE operand"]
    pub const arm_setend_type_ARM_SETEND_LE: root::arm_setend_type = 2;
    #[doc = " Operand type for SETEND instruction"]
    pub type arm_setend_type = cty::c_int;
    pub const arm_cpsmode_type_ARM_CPSMODE_INVALID: root::arm_cpsmode_type = 0;
    pub const arm_cpsmode_type_ARM_CPSMODE_IE: root::arm_cpsmode_type = 2;
    pub const arm_cpsmode_type_ARM_CPSMODE_ID: root::arm_cpsmode_type = 3;
    pub type arm_cpsmode_type = cty::c_int;
    pub const arm_cpsflag_type_ARM_CPSFLAG_INVALID: root::arm_cpsflag_type = 0;
    pub const arm_cpsflag_type_ARM_CPSFLAG_F: root::arm_cpsflag_type = 1;
    pub const arm_cpsflag_type_ARM_CPSFLAG_I: root::arm_cpsflag_type = 2;
    pub const arm_cpsflag_type_ARM_CPSFLAG_A: root::arm_cpsflag_type = 4;
    #[doc = "< no flag"]
    pub const arm_cpsflag_type_ARM_CPSFLAG_NONE: root::arm_cpsflag_type = 16;
    #[doc = " Operand type for SETEND instruction"]
    pub type arm_cpsflag_type = cty::c_int;
    pub const arm_vectordata_type_ARM_VECTORDATA_INVALID: root::arm_vectordata_type = 0;
    pub const arm_vectordata_type_ARM_VECTORDATA_I8: root::arm_vectordata_type = 1;
    pub const arm_vectordata_type_ARM_VECTORDATA_I16: root::arm_vectordata_type = 2;
    pub const arm_vectordata_type_ARM_VECTORDATA_I32: root::arm_vectordata_type = 3;
    pub const arm_vectordata_type_ARM_VECTORDATA_I64: root::arm_vectordata_type = 4;
    pub const arm_vectordata_type_ARM_VECTORDATA_S8: root::arm_vectordata_type = 5;
    pub const arm_vectordata_type_ARM_VECTORDATA_S16: root::arm_vectordata_type = 6;
    pub const arm_vectordata_type_ARM_VECTORDATA_S32: root::arm_vectordata_type = 7;
    pub const arm_vectordata_type_ARM_VECTORDATA_S64: root::arm_vectordata_type = 8;
    pub const arm_vectordata_type_ARM_VECTORDATA_U8: root::arm_vectordata_type = 9;
    pub const arm_vectordata_type_ARM_VECTORDATA_U16: root::arm_vectordata_type = 10;
    pub const arm_vectordata_type_ARM_VECTORDATA_U32: root::arm_vectordata_type = 11;
    pub const arm_vectordata_type_ARM_VECTORDATA_U64: root::arm_vectordata_type = 12;
    pub const arm_vectordata_type_ARM_VECTORDATA_P8: root::arm_vectordata_type = 13;
    pub const arm_vectordata_type_ARM_VECTORDATA_F16: root::arm_vectordata_type = 14;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32: root::arm_vectordata_type = 15;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64: root::arm_vectordata_type = 16;
    pub const arm_vectordata_type_ARM_VECTORDATA_F16F64: root::arm_vectordata_type = 17;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64F16: root::arm_vectordata_type = 18;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32F16: root::arm_vectordata_type = 19;
    pub const arm_vectordata_type_ARM_VECTORDATA_F16F32: root::arm_vectordata_type = 20;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64F32: root::arm_vectordata_type = 21;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32F64: root::arm_vectordata_type = 22;
    pub const arm_vectordata_type_ARM_VECTORDATA_S32F32: root::arm_vectordata_type = 23;
    pub const arm_vectordata_type_ARM_VECTORDATA_U32F32: root::arm_vectordata_type = 24;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32S32: root::arm_vectordata_type = 25;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32U32: root::arm_vectordata_type = 26;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64S16: root::arm_vectordata_type = 27;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32S16: root::arm_vectordata_type = 28;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64S32: root::arm_vectordata_type = 29;
    pub const arm_vectordata_type_ARM_VECTORDATA_S16F64: root::arm_vectordata_type = 30;
    pub const arm_vectordata_type_ARM_VECTORDATA_S16F32: root::arm_vectordata_type = 31;
    pub const arm_vectordata_type_ARM_VECTORDATA_S32F64: root::arm_vectordata_type = 32;
    pub const arm_vectordata_type_ARM_VECTORDATA_U16F64: root::arm_vectordata_type = 33;
    pub const arm_vectordata_type_ARM_VECTORDATA_U16F32: root::arm_vectordata_type = 34;
    pub const arm_vectordata_type_ARM_VECTORDATA_U32F64: root::arm_vectordata_type = 35;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64U16: root::arm_vectordata_type = 36;
    pub const arm_vectordata_type_ARM_VECTORDATA_F32U16: root::arm_vectordata_type = 37;
    pub const arm_vectordata_type_ARM_VECTORDATA_F64U32: root::arm_vectordata_type = 38;
    pub const arm_vectordata_type_ARM_VECTORDATA_F16U16: root::arm_vectordata_type = 39;
    pub const arm_vectordata_type_ARM_VECTORDATA_U16F16: root::arm_vectordata_type = 40;
    pub const arm_vectordata_type_ARM_VECTORDATA_F16U32: root::arm_vectordata_type = 41;
    pub const arm_vectordata_type_ARM_VECTORDATA_U32F16: root::arm_vectordata_type = 42;
    #[doc = " Data type for elements of vector instructions."]
    pub type arm_vectordata_type = cty::c_int;
    pub const arm_reg_ARM_REG_INVALID: root::arm_reg = 0;
    pub const arm_reg_ARM_REG_APSR: root::arm_reg = 1;
    pub const arm_reg_ARM_REG_APSR_NZCV: root::arm_reg = 2;
    pub const arm_reg_ARM_REG_CPSR: root::arm_reg = 3;
    pub const arm_reg_ARM_REG_FPEXC: root::arm_reg = 4;
    pub const arm_reg_ARM_REG_FPINST: root::arm_reg = 5;
    pub const arm_reg_ARM_REG_FPSCR: root::arm_reg = 6;
    pub const arm_reg_ARM_REG_FPSCR_NZCV: root::arm_reg = 7;
    pub const arm_reg_ARM_REG_FPSID: root::arm_reg = 8;
    pub const arm_reg_ARM_REG_ITSTATE: root::arm_reg = 9;
    pub const arm_reg_ARM_REG_LR: root::arm_reg = 10;
    pub const arm_reg_ARM_REG_PC: root::arm_reg = 11;
    pub const arm_reg_ARM_REG_SP: root::arm_reg = 12;
    pub const arm_reg_ARM_REG_SPSR: root::arm_reg = 13;
    pub const arm_reg_ARM_REG_D0: root::arm_reg = 14;
    pub const arm_reg_ARM_REG_D1: root::arm_reg = 15;
    pub const arm_reg_ARM_REG_D2: root::arm_reg = 16;
    pub const arm_reg_ARM_REG_D3: root::arm_reg = 17;
    pub const arm_reg_ARM_REG_D4: root::arm_reg = 18;
    pub const arm_reg_ARM_REG_D5: root::arm_reg = 19;
    pub const arm_reg_ARM_REG_D6: root::arm_reg = 20;
    pub const arm_reg_ARM_REG_D7: root::arm_reg = 21;
    pub const arm_reg_ARM_REG_D8: root::arm_reg = 22;
    pub const arm_reg_ARM_REG_D9: root::arm_reg = 23;
    pub const arm_reg_ARM_REG_D10: root::arm_reg = 24;
    pub const arm_reg_ARM_REG_D11: root::arm_reg = 25;
    pub const arm_reg_ARM_REG_D12: root::arm_reg = 26;
    pub const arm_reg_ARM_REG_D13: root::arm_reg = 27;
    pub const arm_reg_ARM_REG_D14: root::arm_reg = 28;
    pub const arm_reg_ARM_REG_D15: root::arm_reg = 29;
    pub const arm_reg_ARM_REG_D16: root::arm_reg = 30;
    pub const arm_reg_ARM_REG_D17: root::arm_reg = 31;
    pub const arm_reg_ARM_REG_D18: root::arm_reg = 32;
    pub const arm_reg_ARM_REG_D19: root::arm_reg = 33;
    pub const arm_reg_ARM_REG_D20: root::arm_reg = 34;
    pub const arm_reg_ARM_REG_D21: root::arm_reg = 35;
    pub const arm_reg_ARM_REG_D22: root::arm_reg = 36;
    pub const arm_reg_ARM_REG_D23: root::arm_reg = 37;
    pub const arm_reg_ARM_REG_D24: root::arm_reg = 38;
    pub const arm_reg_ARM_REG_D25: root::arm_reg = 39;
    pub const arm_reg_ARM_REG_D26: root::arm_reg = 40;
    pub const arm_reg_ARM_REG_D27: root::arm_reg = 41;
    pub const arm_reg_ARM_REG_D28: root::arm_reg = 42;
    pub const arm_reg_ARM_REG_D29: root::arm_reg = 43;
    pub const arm_reg_ARM_REG_D30: root::arm_reg = 44;
    pub const arm_reg_ARM_REG_D31: root::arm_reg = 45;
    pub const arm_reg_ARM_REG_FPINST2: root::arm_reg = 46;
    pub const arm_reg_ARM_REG_MVFR0: root::arm_reg = 47;
    pub const arm_reg_ARM_REG_MVFR1: root::arm_reg = 48;
    pub const arm_reg_ARM_REG_MVFR2: root::arm_reg = 49;
    pub const arm_reg_ARM_REG_Q0: root::arm_reg = 50;
    pub const arm_reg_ARM_REG_Q1: root::arm_reg = 51;
    pub const arm_reg_ARM_REG_Q2: root::arm_reg = 52;
    pub const arm_reg_ARM_REG_Q3: root::arm_reg = 53;
    pub const arm_reg_ARM_REG_Q4: root::arm_reg = 54;
    pub const arm_reg_ARM_REG_Q5: root::arm_reg = 55;
    pub const arm_reg_ARM_REG_Q6: root::arm_reg = 56;
    pub const arm_reg_ARM_REG_Q7: root::arm_reg = 57;
    pub const arm_reg_ARM_REG_Q8: root::arm_reg = 58;
    pub const arm_reg_ARM_REG_Q9: root::arm_reg = 59;
    pub const arm_reg_ARM_REG_Q10: root::arm_reg = 60;
    pub const arm_reg_ARM_REG_Q11: root::arm_reg = 61;
    pub const arm_reg_ARM_REG_Q12: root::arm_reg = 62;
    pub const arm_reg_ARM_REG_Q13: root::arm_reg = 63;
    pub const arm_reg_ARM_REG_Q14: root::arm_reg = 64;
    pub const arm_reg_ARM_REG_Q15: root::arm_reg = 65;
    pub const arm_reg_ARM_REG_R0: root::arm_reg = 66;
    pub const arm_reg_ARM_REG_R1: root::arm_reg = 67;
    pub const arm_reg_ARM_REG_R2: root::arm_reg = 68;
    pub const arm_reg_ARM_REG_R3: root::arm_reg = 69;
    pub const arm_reg_ARM_REG_R4: root::arm_reg = 70;
    pub const arm_reg_ARM_REG_R5: root::arm_reg = 71;
    pub const arm_reg_ARM_REG_R6: root::arm_reg = 72;
    pub const arm_reg_ARM_REG_R7: root::arm_reg = 73;
    pub const arm_reg_ARM_REG_R8: root::arm_reg = 74;
    pub const arm_reg_ARM_REG_R9: root::arm_reg = 75;
    pub const arm_reg_ARM_REG_R10: root::arm_reg = 76;
    pub const arm_reg_ARM_REG_R11: root::arm_reg = 77;
    pub const arm_reg_ARM_REG_R12: root::arm_reg = 78;
    pub const arm_reg_ARM_REG_S0: root::arm_reg = 79;
    pub const arm_reg_ARM_REG_S1: root::arm_reg = 80;
    pub const arm_reg_ARM_REG_S2: root::arm_reg = 81;
    pub const arm_reg_ARM_REG_S3: root::arm_reg = 82;
    pub const arm_reg_ARM_REG_S4: root::arm_reg = 83;
    pub const arm_reg_ARM_REG_S5: root::arm_reg = 84;
    pub const arm_reg_ARM_REG_S6: root::arm_reg = 85;
    pub const arm_reg_ARM_REG_S7: root::arm_reg = 86;
    pub const arm_reg_ARM_REG_S8: root::arm_reg = 87;
    pub const arm_reg_ARM_REG_S9: root::arm_reg = 88;
    pub const arm_reg_ARM_REG_S10: root::arm_reg = 89;
    pub const arm_reg_ARM_REG_S11: root::arm_reg = 90;
    pub const arm_reg_ARM_REG_S12: root::arm_reg = 91;
    pub const arm_reg_ARM_REG_S13: root::arm_reg = 92;
    pub const arm_reg_ARM_REG_S14: root::arm_reg = 93;
    pub const arm_reg_ARM_REG_S15: root::arm_reg = 94;
    pub const arm_reg_ARM_REG_S16: root::arm_reg = 95;
    pub const arm_reg_ARM_REG_S17: root::arm_reg = 96;
    pub const arm_reg_ARM_REG_S18: root::arm_reg = 97;
    pub const arm_reg_ARM_REG_S19: root::arm_reg = 98;
    pub const arm_reg_ARM_REG_S20: root::arm_reg = 99;
    pub const arm_reg_ARM_REG_S21: root::arm_reg = 100;
    pub const arm_reg_ARM_REG_S22: root::arm_reg = 101;
    pub const arm_reg_ARM_REG_S23: root::arm_reg = 102;
    pub const arm_reg_ARM_REG_S24: root::arm_reg = 103;
    pub const arm_reg_ARM_REG_S25: root::arm_reg = 104;
    pub const arm_reg_ARM_REG_S26: root::arm_reg = 105;
    pub const arm_reg_ARM_REG_S27: root::arm_reg = 106;
    pub const arm_reg_ARM_REG_S28: root::arm_reg = 107;
    pub const arm_reg_ARM_REG_S29: root::arm_reg = 108;
    pub const arm_reg_ARM_REG_S30: root::arm_reg = 109;
    pub const arm_reg_ARM_REG_S31: root::arm_reg = 110;
    pub const arm_reg_ARM_REG_ENDING: root::arm_reg = 111;
    pub const arm_reg_ARM_REG_R13: root::arm_reg = 12;
    pub const arm_reg_ARM_REG_R14: root::arm_reg = 10;
    pub const arm_reg_ARM_REG_R15: root::arm_reg = 11;
    pub const arm_reg_ARM_REG_SB: root::arm_reg = 75;
    pub const arm_reg_ARM_REG_SL: root::arm_reg = 76;
    pub const arm_reg_ARM_REG_FP: root::arm_reg = 77;
    pub const arm_reg_ARM_REG_IP: root::arm_reg = 78;
    #[doc = " ARM registers"]
    pub type arm_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with ARM_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct arm_op_mem {
        #[doc = "< base register"]
        pub base: root::arm_reg,
        #[doc = "< index register"]
        pub index: root::arm_reg,
        #[doc = "< scale for index register (can be 1, or -1)"]
        pub scale: cty::c_int,
        #[doc = "< displacement/offset value"]
        pub disp: cty::c_int,
        #[doc = " left-shift on index register, or 0 if irrelevant"]
        #[doc = " NOTE: this value can also be fetched via operand.shift.value"]
        pub lshift: cty::c_int,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_arm_op {
        #[doc = "< Vector Index for some vector operands (or -1 if irrelevant)"]
        pub vector_index: cty::c_int,
        pub shift: root::cs_arm_op__bindgen_ty_1,
        #[doc = "< operand type"]
        pub type_: root::arm_op_type,
        pub __bindgen_anon_1: root::cs_arm_op__bindgen_ty_2,
        #[doc = " in some instructions, an operand can be subtracted or added to"]
        #[doc = " the base register,"]
        #[doc = " if TRUE, this operand is subtracted. otherwise, it is added."]
        pub subtracted: bool,
        #[doc = " How is this operand accessed? (READ, WRITE or READ|WRITE)"]
        #[doc = " This field is combined of cs_ac_type."]
        #[doc = " NOTE: this field is irrelevant if engine is compiled in DIET mode."]
        pub access: u8,
        #[doc = " Neon lane index for NEON instructions (or -1 if irrelevant)"]
        pub neon_lane: i8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_arm_op__bindgen_ty_1 {
        pub type_: root::arm_shifter,
        pub value: cty::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_arm_op__bindgen_ty_2 {
        #[doc = "< register value for REG/SYSREG operand"]
        pub reg: cty::c_int,
        #[doc = "< immediate value for C-IMM, P-IMM or IMM operand"]
        pub imm: i32,
        #[doc = "< floating point value for FP operand"]
        pub fp: f64,
        #[doc = "< base/index/scale/disp value for MEM operand"]
        pub mem: root::arm_op_mem,
        #[doc = "< SETEND instruction's operand type"]
        pub setend: root::arm_setend_type,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_arm {
        #[doc = "< User-mode registers to be loaded (for LDM/STM instructions)"]
        pub usermode: bool,
        #[doc = "< Scalar size for vector instructions"]
        pub vector_size: cty::c_int,
        #[doc = "< Data type for elements of vector instructions"]
        pub vector_data: root::arm_vectordata_type,
        #[doc = "< CPS mode for CPS instruction"]
        pub cps_mode: root::arm_cpsmode_type,
        #[doc = "< CPS mode for CPS instruction"]
        pub cps_flag: root::arm_cpsflag_type,
        #[doc = "< conditional code for this insn"]
        pub cc: root::arm_cc,
        #[doc = "< does this insn update flags?"]
        pub update_flags: bool,
        #[doc = "< does this insn write-back?"]
        pub writeback: bool,
        #[doc = "< Option for some memory barrier instructions"]
        pub mem_barrier: root::arm_mem_barrier,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_arm_op; 36usize],
    }
    pub const arm64_shifter_ARM64_SFT_INVALID: root::arm64_shifter = 0;
    pub const arm64_shifter_ARM64_SFT_LSL: root::arm64_shifter = 1;
    pub const arm64_shifter_ARM64_SFT_MSL: root::arm64_shifter = 2;
    pub const arm64_shifter_ARM64_SFT_LSR: root::arm64_shifter = 3;
    pub const arm64_shifter_ARM64_SFT_ASR: root::arm64_shifter = 4;
    pub const arm64_shifter_ARM64_SFT_ROR: root::arm64_shifter = 5;
    #[doc = " ARM64 shift type"]
    pub type arm64_shifter = cty::c_int;
    pub const arm64_extender_ARM64_EXT_INVALID: root::arm64_extender = 0;
    pub const arm64_extender_ARM64_EXT_UXTB: root::arm64_extender = 1;
    pub const arm64_extender_ARM64_EXT_UXTH: root::arm64_extender = 2;
    pub const arm64_extender_ARM64_EXT_UXTW: root::arm64_extender = 3;
    pub const arm64_extender_ARM64_EXT_UXTX: root::arm64_extender = 4;
    pub const arm64_extender_ARM64_EXT_SXTB: root::arm64_extender = 5;
    pub const arm64_extender_ARM64_EXT_SXTH: root::arm64_extender = 6;
    pub const arm64_extender_ARM64_EXT_SXTW: root::arm64_extender = 7;
    pub const arm64_extender_ARM64_EXT_SXTX: root::arm64_extender = 8;
    #[doc = " ARM64 extender type"]
    pub type arm64_extender = cty::c_int;
    pub const arm64_cc_ARM64_CC_INVALID: root::arm64_cc = 0;
    #[doc = "< Equal"]
    pub const arm64_cc_ARM64_CC_EQ: root::arm64_cc = 1;
    #[doc = "< Not equal:                 Not equal, or unordered"]
    pub const arm64_cc_ARM64_CC_NE: root::arm64_cc = 2;
    #[doc = "< Unsigned higher or same:   >, ==, or unordered"]
    pub const arm64_cc_ARM64_CC_HS: root::arm64_cc = 3;
    #[doc = "< Unsigned lower or same:    Less than"]
    pub const arm64_cc_ARM64_CC_LO: root::arm64_cc = 4;
    #[doc = "< Minus, negative:           Less than"]
    pub const arm64_cc_ARM64_CC_MI: root::arm64_cc = 5;
    #[doc = "< Plus, positive or zero:    >, ==, or unordered"]
    pub const arm64_cc_ARM64_CC_PL: root::arm64_cc = 6;
    #[doc = "< Overflow:                  Unordered"]
    pub const arm64_cc_ARM64_CC_VS: root::arm64_cc = 7;
    #[doc = "< No overflow:               Ordered"]
    pub const arm64_cc_ARM64_CC_VC: root::arm64_cc = 8;
    #[doc = "< Unsigned higher:           Greater than, or unordered"]
    pub const arm64_cc_ARM64_CC_HI: root::arm64_cc = 9;
    #[doc = "< Unsigned lower or same:    Less than or equal"]
    pub const arm64_cc_ARM64_CC_LS: root::arm64_cc = 10;
    #[doc = "< Greater than or equal:     Greater than or equal"]
    pub const arm64_cc_ARM64_CC_GE: root::arm64_cc = 11;
    #[doc = "< Less than:                 Less than, or unordered"]
    pub const arm64_cc_ARM64_CC_LT: root::arm64_cc = 12;
    #[doc = "< Signed greater than:       Greater than"]
    pub const arm64_cc_ARM64_CC_GT: root::arm64_cc = 13;
    #[doc = "< Signed less than or equal: <, ==, or unordered"]
    pub const arm64_cc_ARM64_CC_LE: root::arm64_cc = 14;
    #[doc = "< Always (unconditional):    Always (unconditional)"]
    pub const arm64_cc_ARM64_CC_AL: root::arm64_cc = 15;
    #[doc = "< Always (unconditional):   Always (unconditional)"]
    pub const arm64_cc_ARM64_CC_NV: root::arm64_cc = 16;
    #[doc = " ARM64 condition code"]
    pub type arm64_cc = cty::c_int;
    pub const arm64_pstate_ARM64_PSTATE_INVALID: root::arm64_pstate = 0;
    pub const arm64_pstate_ARM64_PSTATE_SPSEL: root::arm64_pstate = 5;
    pub const arm64_pstate_ARM64_PSTATE_DAIFSET: root::arm64_pstate = 30;
    pub const arm64_pstate_ARM64_PSTATE_DAIFCLR: root::arm64_pstate = 31;
    pub const arm64_pstate_ARM64_PSTATE_PAN: root::arm64_pstate = 4;
    pub const arm64_pstate_ARM64_PSTATE_UAO: root::arm64_pstate = 3;
    pub const arm64_pstate_ARM64_PSTATE_DIT: root::arm64_pstate = 26;
    #[doc = " System PState Field (MSR instruction)"]
    pub type arm64_pstate = cty::c_int;
    pub const arm64_vas_ARM64_VAS_INVALID: root::arm64_vas = 0;
    pub const arm64_vas_ARM64_VAS_16B: root::arm64_vas = 1;
    pub const arm64_vas_ARM64_VAS_8B: root::arm64_vas = 2;
    pub const arm64_vas_ARM64_VAS_4B: root::arm64_vas = 3;
    pub const arm64_vas_ARM64_VAS_1B: root::arm64_vas = 4;
    pub const arm64_vas_ARM64_VAS_8H: root::arm64_vas = 5;
    pub const arm64_vas_ARM64_VAS_4H: root::arm64_vas = 6;
    pub const arm64_vas_ARM64_VAS_2H: root::arm64_vas = 7;
    pub const arm64_vas_ARM64_VAS_1H: root::arm64_vas = 8;
    pub const arm64_vas_ARM64_VAS_4S: root::arm64_vas = 9;
    pub const arm64_vas_ARM64_VAS_2S: root::arm64_vas = 10;
    pub const arm64_vas_ARM64_VAS_1S: root::arm64_vas = 11;
    pub const arm64_vas_ARM64_VAS_2D: root::arm64_vas = 12;
    pub const arm64_vas_ARM64_VAS_1D: root::arm64_vas = 13;
    pub const arm64_vas_ARM64_VAS_1Q: root::arm64_vas = 14;
    #[doc = " Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)"]
    pub type arm64_vas = cty::c_int;
    pub const arm64_barrier_op_ARM64_BARRIER_INVALID: root::arm64_barrier_op = 0;
    pub const arm64_barrier_op_ARM64_BARRIER_OSHLD: root::arm64_barrier_op = 1;
    pub const arm64_barrier_op_ARM64_BARRIER_OSHST: root::arm64_barrier_op = 2;
    pub const arm64_barrier_op_ARM64_BARRIER_OSH: root::arm64_barrier_op = 3;
    pub const arm64_barrier_op_ARM64_BARRIER_NSHLD: root::arm64_barrier_op = 5;
    pub const arm64_barrier_op_ARM64_BARRIER_NSHST: root::arm64_barrier_op = 6;
    pub const arm64_barrier_op_ARM64_BARRIER_NSH: root::arm64_barrier_op = 7;
    pub const arm64_barrier_op_ARM64_BARRIER_ISHLD: root::arm64_barrier_op = 9;
    pub const arm64_barrier_op_ARM64_BARRIER_ISHST: root::arm64_barrier_op = 10;
    pub const arm64_barrier_op_ARM64_BARRIER_ISH: root::arm64_barrier_op = 11;
    pub const arm64_barrier_op_ARM64_BARRIER_LD: root::arm64_barrier_op = 13;
    pub const arm64_barrier_op_ARM64_BARRIER_ST: root::arm64_barrier_op = 14;
    pub const arm64_barrier_op_ARM64_BARRIER_SY: root::arm64_barrier_op = 15;
    #[doc = " Memory barrier operands"]
    pub type arm64_barrier_op = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const arm64_op_type_ARM64_OP_INVALID: root::arm64_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const arm64_op_type_ARM64_OP_REG: root::arm64_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const arm64_op_type_ARM64_OP_IMM: root::arm64_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const arm64_op_type_ARM64_OP_MEM: root::arm64_op_type = 3;
    #[doc = "< = CS_OP_FP (Floating-Point operand)."]
    pub const arm64_op_type_ARM64_OP_FP: root::arm64_op_type = 4;
    #[doc = "< C-Immediate"]
    pub const arm64_op_type_ARM64_OP_CIMM: root::arm64_op_type = 64;
    #[doc = "< MRS register operand."]
    pub const arm64_op_type_ARM64_OP_REG_MRS: root::arm64_op_type = 65;
    #[doc = "< MSR register operand."]
    pub const arm64_op_type_ARM64_OP_REG_MSR: root::arm64_op_type = 66;
    #[doc = "< PState operand."]
    pub const arm64_op_type_ARM64_OP_PSTATE: root::arm64_op_type = 67;
    #[doc = "< SYS operand for IC/DC/AT/TLBI instructions."]
    pub const arm64_op_type_ARM64_OP_SYS: root::arm64_op_type = 68;
    #[doc = "< Prefetch operand (PRFM)."]
    pub const arm64_op_type_ARM64_OP_PREFETCH: root::arm64_op_type = 69;
    #[doc = "< Memory barrier operand (ISB/DMB/DSB instructions)."]
    pub const arm64_op_type_ARM64_OP_BARRIER: root::arm64_op_type = 70;
    #[doc = " Operand type for instruction's operands"]
    pub type arm64_op_type = cty::c_int;
    pub const arm64_sys_op_ARM64_SYS_INVALID: root::arm64_sys_op = 0;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_IPAS2E1IS: root::arm64_sys_op = 1;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_IPAS2LE1IS: root::arm64_sys_op = 2;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VMALLE1IS: root::arm64_sys_op = 3;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE2IS: root::arm64_sys_op = 4;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE3IS: root::arm64_sys_op = 5;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE1IS: root::arm64_sys_op = 6;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE2IS: root::arm64_sys_op = 7;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE3IS: root::arm64_sys_op = 8;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ASIDE1IS: root::arm64_sys_op = 9;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAAE1IS: root::arm64_sys_op = 10;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE1IS: root::arm64_sys_op = 11;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE1IS: root::arm64_sys_op = 12;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE2IS: root::arm64_sys_op = 13;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE3IS: root::arm64_sys_op = 14;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VMALLS12E1IS: root::arm64_sys_op = 15;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAALE1IS: root::arm64_sys_op = 16;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_IPAS2E1: root::arm64_sys_op = 17;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_IPAS2LE1: root::arm64_sys_op = 18;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VMALLE1: root::arm64_sys_op = 19;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE2: root::arm64_sys_op = 20;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE3: root::arm64_sys_op = 21;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE1: root::arm64_sys_op = 22;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE2: root::arm64_sys_op = 23;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE3: root::arm64_sys_op = 24;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ASIDE1: root::arm64_sys_op = 25;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAAE1: root::arm64_sys_op = 26;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE1: root::arm64_sys_op = 27;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE1: root::arm64_sys_op = 28;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE2: root::arm64_sys_op = 29;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE3: root::arm64_sys_op = 30;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VMALLS12E1: root::arm64_sys_op = 31;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAALE1: root::arm64_sys_op = 32;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VMALLE1OS: root::arm64_sys_op = 33;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE1OS: root::arm64_sys_op = 34;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ASIDE1OS: root::arm64_sys_op = 35;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAAE1OS: root::arm64_sys_op = 36;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE1OS: root::arm64_sys_op = 37;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAALE1OS: root::arm64_sys_op = 38;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_IPAS2E1OS: root::arm64_sys_op = 39;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_IPAS2LE1OS: root::arm64_sys_op = 40;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE2OS: root::arm64_sys_op = 41;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE2OS: root::arm64_sys_op = 42;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VMALLS12E1OS: root::arm64_sys_op = 43;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VAE3OS: root::arm64_sys_op = 44;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_VALE3OS: root::arm64_sys_op = 45;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE2OS: root::arm64_sys_op = 46;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE1OS: root::arm64_sys_op = 47;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_ALLE3OS: root::arm64_sys_op = 48;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE1: root::arm64_sys_op = 49;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAAE1: root::arm64_sys_op = 50;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE1: root::arm64_sys_op = 51;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAALE1: root::arm64_sys_op = 52;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE1IS: root::arm64_sys_op = 53;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAAE1IS: root::arm64_sys_op = 54;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE1IS: root::arm64_sys_op = 55;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAALE1IS: root::arm64_sys_op = 56;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE1OS: root::arm64_sys_op = 57;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAAE1OS: root::arm64_sys_op = 58;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE1OS: root::arm64_sys_op = 59;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAALE1OS: root::arm64_sys_op = 60;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RIPAS2E1IS: root::arm64_sys_op = 61;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RIPAS2LE1IS: root::arm64_sys_op = 62;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RIPAS2E1: root::arm64_sys_op = 63;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RIPAS2LE1: root::arm64_sys_op = 64;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RIPAS2E1OS: root::arm64_sys_op = 65;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RIPAS2LE1OS: root::arm64_sys_op = 66;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE2: root::arm64_sys_op = 67;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE2: root::arm64_sys_op = 68;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE2IS: root::arm64_sys_op = 69;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE2IS: root::arm64_sys_op = 70;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE2OS: root::arm64_sys_op = 71;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE2OS: root::arm64_sys_op = 72;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE3: root::arm64_sys_op = 73;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE3: root::arm64_sys_op = 74;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE3IS: root::arm64_sys_op = 75;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE3IS: root::arm64_sys_op = 76;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVAE3OS: root::arm64_sys_op = 77;
    #[doc = " TLBI operations"]
    pub const arm64_sys_op_ARM64_TLBI_RVALE3OS: root::arm64_sys_op = 78;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E1R: root::arm64_sys_op = 79;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E2R: root::arm64_sys_op = 80;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E3R: root::arm64_sys_op = 81;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E1W: root::arm64_sys_op = 82;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E2W: root::arm64_sys_op = 83;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E3W: root::arm64_sys_op = 84;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E0R: root::arm64_sys_op = 85;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E0W: root::arm64_sys_op = 86;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S12E1R: root::arm64_sys_op = 87;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S12E1W: root::arm64_sys_op = 88;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S12E0R: root::arm64_sys_op = 89;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S12E0W: root::arm64_sys_op = 90;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E1RP: root::arm64_sys_op = 91;
    #[doc = " AT operations"]
    pub const arm64_sys_op_ARM64_AT_S1E1WP: root::arm64_sys_op = 92;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_ZVA: root::arm64_sys_op = 93;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_IVAC: root::arm64_sys_op = 94;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_ISW: root::arm64_sys_op = 95;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_CVAC: root::arm64_sys_op = 96;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_CSW: root::arm64_sys_op = 97;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_CVAU: root::arm64_sys_op = 98;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_CIVAC: root::arm64_sys_op = 99;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_CISW: root::arm64_sys_op = 100;
    #[doc = " DC operations"]
    pub const arm64_sys_op_ARM64_DC_CVAP: root::arm64_sys_op = 101;
    #[doc = " IC operations"]
    pub const arm64_sys_op_ARM64_IC_IALLUIS: root::arm64_sys_op = 102;
    #[doc = " IC operations"]
    pub const arm64_sys_op_ARM64_IC_IALLU: root::arm64_sys_op = 103;
    #[doc = " IC operations"]
    pub const arm64_sys_op_ARM64_IC_IVAU: root::arm64_sys_op = 104;
    #[doc = " SYS operands (IC/DC/AC/TLBI)"]
    pub type arm64_sys_op = cty::c_int;
    pub const arm64_prefetch_op_ARM64_PRFM_INVALID: root::arm64_prefetch_op = 0;
    pub const arm64_prefetch_op_ARM64_PRFM_PLDL1KEEP: root::arm64_prefetch_op = 1;
    pub const arm64_prefetch_op_ARM64_PRFM_PLDL1STRM: root::arm64_prefetch_op = 2;
    pub const arm64_prefetch_op_ARM64_PRFM_PLDL2KEEP: root::arm64_prefetch_op = 3;
    pub const arm64_prefetch_op_ARM64_PRFM_PLDL2STRM: root::arm64_prefetch_op = 4;
    pub const arm64_prefetch_op_ARM64_PRFM_PLDL3KEEP: root::arm64_prefetch_op = 5;
    pub const arm64_prefetch_op_ARM64_PRFM_PLDL3STRM: root::arm64_prefetch_op = 6;
    pub const arm64_prefetch_op_ARM64_PRFM_PLIL1KEEP: root::arm64_prefetch_op = 9;
    pub const arm64_prefetch_op_ARM64_PRFM_PLIL1STRM: root::arm64_prefetch_op = 10;
    pub const arm64_prefetch_op_ARM64_PRFM_PLIL2KEEP: root::arm64_prefetch_op = 11;
    pub const arm64_prefetch_op_ARM64_PRFM_PLIL2STRM: root::arm64_prefetch_op = 12;
    pub const arm64_prefetch_op_ARM64_PRFM_PLIL3KEEP: root::arm64_prefetch_op = 13;
    pub const arm64_prefetch_op_ARM64_PRFM_PLIL3STRM: root::arm64_prefetch_op = 14;
    pub const arm64_prefetch_op_ARM64_PRFM_PSTL1KEEP: root::arm64_prefetch_op = 17;
    pub const arm64_prefetch_op_ARM64_PRFM_PSTL1STRM: root::arm64_prefetch_op = 18;
    pub const arm64_prefetch_op_ARM64_PRFM_PSTL2KEEP: root::arm64_prefetch_op = 19;
    pub const arm64_prefetch_op_ARM64_PRFM_PSTL2STRM: root::arm64_prefetch_op = 20;
    pub const arm64_prefetch_op_ARM64_PRFM_PSTL3KEEP: root::arm64_prefetch_op = 21;
    pub const arm64_prefetch_op_ARM64_PRFM_PSTL3STRM: root::arm64_prefetch_op = 22;
    #[doc = " Prefetch operations (PRFM)"]
    pub type arm64_prefetch_op = cty::c_int;
    pub const arm64_reg_ARM64_REG_INVALID: root::arm64_reg = 0;
    pub const arm64_reg_ARM64_REG_FFR: root::arm64_reg = 1;
    pub const arm64_reg_ARM64_REG_FP: root::arm64_reg = 2;
    pub const arm64_reg_ARM64_REG_LR: root::arm64_reg = 3;
    pub const arm64_reg_ARM64_REG_NZCV: root::arm64_reg = 4;
    pub const arm64_reg_ARM64_REG_SP: root::arm64_reg = 5;
    pub const arm64_reg_ARM64_REG_WSP: root::arm64_reg = 6;
    pub const arm64_reg_ARM64_REG_WZR: root::arm64_reg = 7;
    pub const arm64_reg_ARM64_REG_XZR: root::arm64_reg = 8;
    pub const arm64_reg_ARM64_REG_B0: root::arm64_reg = 9;
    pub const arm64_reg_ARM64_REG_B1: root::arm64_reg = 10;
    pub const arm64_reg_ARM64_REG_B2: root::arm64_reg = 11;
    pub const arm64_reg_ARM64_REG_B3: root::arm64_reg = 12;
    pub const arm64_reg_ARM64_REG_B4: root::arm64_reg = 13;
    pub const arm64_reg_ARM64_REG_B5: root::arm64_reg = 14;
    pub const arm64_reg_ARM64_REG_B6: root::arm64_reg = 15;
    pub const arm64_reg_ARM64_REG_B7: root::arm64_reg = 16;
    pub const arm64_reg_ARM64_REG_B8: root::arm64_reg = 17;
    pub const arm64_reg_ARM64_REG_B9: root::arm64_reg = 18;
    pub const arm64_reg_ARM64_REG_B10: root::arm64_reg = 19;
    pub const arm64_reg_ARM64_REG_B11: root::arm64_reg = 20;
    pub const arm64_reg_ARM64_REG_B12: root::arm64_reg = 21;
    pub const arm64_reg_ARM64_REG_B13: root::arm64_reg = 22;
    pub const arm64_reg_ARM64_REG_B14: root::arm64_reg = 23;
    pub const arm64_reg_ARM64_REG_B15: root::arm64_reg = 24;
    pub const arm64_reg_ARM64_REG_B16: root::arm64_reg = 25;
    pub const arm64_reg_ARM64_REG_B17: root::arm64_reg = 26;
    pub const arm64_reg_ARM64_REG_B18: root::arm64_reg = 27;
    pub const arm64_reg_ARM64_REG_B19: root::arm64_reg = 28;
    pub const arm64_reg_ARM64_REG_B20: root::arm64_reg = 29;
    pub const arm64_reg_ARM64_REG_B21: root::arm64_reg = 30;
    pub const arm64_reg_ARM64_REG_B22: root::arm64_reg = 31;
    pub const arm64_reg_ARM64_REG_B23: root::arm64_reg = 32;
    pub const arm64_reg_ARM64_REG_B24: root::arm64_reg = 33;
    pub const arm64_reg_ARM64_REG_B25: root::arm64_reg = 34;
    pub const arm64_reg_ARM64_REG_B26: root::arm64_reg = 35;
    pub const arm64_reg_ARM64_REG_B27: root::arm64_reg = 36;
    pub const arm64_reg_ARM64_REG_B28: root::arm64_reg = 37;
    pub const arm64_reg_ARM64_REG_B29: root::arm64_reg = 38;
    pub const arm64_reg_ARM64_REG_B30: root::arm64_reg = 39;
    pub const arm64_reg_ARM64_REG_B31: root::arm64_reg = 40;
    pub const arm64_reg_ARM64_REG_D0: root::arm64_reg = 41;
    pub const arm64_reg_ARM64_REG_D1: root::arm64_reg = 42;
    pub const arm64_reg_ARM64_REG_D2: root::arm64_reg = 43;
    pub const arm64_reg_ARM64_REG_D3: root::arm64_reg = 44;
    pub const arm64_reg_ARM64_REG_D4: root::arm64_reg = 45;
    pub const arm64_reg_ARM64_REG_D5: root::arm64_reg = 46;
    pub const arm64_reg_ARM64_REG_D6: root::arm64_reg = 47;
    pub const arm64_reg_ARM64_REG_D7: root::arm64_reg = 48;
    pub const arm64_reg_ARM64_REG_D8: root::arm64_reg = 49;
    pub const arm64_reg_ARM64_REG_D9: root::arm64_reg = 50;
    pub const arm64_reg_ARM64_REG_D10: root::arm64_reg = 51;
    pub const arm64_reg_ARM64_REG_D11: root::arm64_reg = 52;
    pub const arm64_reg_ARM64_REG_D12: root::arm64_reg = 53;
    pub const arm64_reg_ARM64_REG_D13: root::arm64_reg = 54;
    pub const arm64_reg_ARM64_REG_D14: root::arm64_reg = 55;
    pub const arm64_reg_ARM64_REG_D15: root::arm64_reg = 56;
    pub const arm64_reg_ARM64_REG_D16: root::arm64_reg = 57;
    pub const arm64_reg_ARM64_REG_D17: root::arm64_reg = 58;
    pub const arm64_reg_ARM64_REG_D18: root::arm64_reg = 59;
    pub const arm64_reg_ARM64_REG_D19: root::arm64_reg = 60;
    pub const arm64_reg_ARM64_REG_D20: root::arm64_reg = 61;
    pub const arm64_reg_ARM64_REG_D21: root::arm64_reg = 62;
    pub const arm64_reg_ARM64_REG_D22: root::arm64_reg = 63;
    pub const arm64_reg_ARM64_REG_D23: root::arm64_reg = 64;
    pub const arm64_reg_ARM64_REG_D24: root::arm64_reg = 65;
    pub const arm64_reg_ARM64_REG_D25: root::arm64_reg = 66;
    pub const arm64_reg_ARM64_REG_D26: root::arm64_reg = 67;
    pub const arm64_reg_ARM64_REG_D27: root::arm64_reg = 68;
    pub const arm64_reg_ARM64_REG_D28: root::arm64_reg = 69;
    pub const arm64_reg_ARM64_REG_D29: root::arm64_reg = 70;
    pub const arm64_reg_ARM64_REG_D30: root::arm64_reg = 71;
    pub const arm64_reg_ARM64_REG_D31: root::arm64_reg = 72;
    pub const arm64_reg_ARM64_REG_H0: root::arm64_reg = 73;
    pub const arm64_reg_ARM64_REG_H1: root::arm64_reg = 74;
    pub const arm64_reg_ARM64_REG_H2: root::arm64_reg = 75;
    pub const arm64_reg_ARM64_REG_H3: root::arm64_reg = 76;
    pub const arm64_reg_ARM64_REG_H4: root::arm64_reg = 77;
    pub const arm64_reg_ARM64_REG_H5: root::arm64_reg = 78;
    pub const arm64_reg_ARM64_REG_H6: root::arm64_reg = 79;
    pub const arm64_reg_ARM64_REG_H7: root::arm64_reg = 80;
    pub const arm64_reg_ARM64_REG_H8: root::arm64_reg = 81;
    pub const arm64_reg_ARM64_REG_H9: root::arm64_reg = 82;
    pub const arm64_reg_ARM64_REG_H10: root::arm64_reg = 83;
    pub const arm64_reg_ARM64_REG_H11: root::arm64_reg = 84;
    pub const arm64_reg_ARM64_REG_H12: root::arm64_reg = 85;
    pub const arm64_reg_ARM64_REG_H13: root::arm64_reg = 86;
    pub const arm64_reg_ARM64_REG_H14: root::arm64_reg = 87;
    pub const arm64_reg_ARM64_REG_H15: root::arm64_reg = 88;
    pub const arm64_reg_ARM64_REG_H16: root::arm64_reg = 89;
    pub const arm64_reg_ARM64_REG_H17: root::arm64_reg = 90;
    pub const arm64_reg_ARM64_REG_H18: root::arm64_reg = 91;
    pub const arm64_reg_ARM64_REG_H19: root::arm64_reg = 92;
    pub const arm64_reg_ARM64_REG_H20: root::arm64_reg = 93;
    pub const arm64_reg_ARM64_REG_H21: root::arm64_reg = 94;
    pub const arm64_reg_ARM64_REG_H22: root::arm64_reg = 95;
    pub const arm64_reg_ARM64_REG_H23: root::arm64_reg = 96;
    pub const arm64_reg_ARM64_REG_H24: root::arm64_reg = 97;
    pub const arm64_reg_ARM64_REG_H25: root::arm64_reg = 98;
    pub const arm64_reg_ARM64_REG_H26: root::arm64_reg = 99;
    pub const arm64_reg_ARM64_REG_H27: root::arm64_reg = 100;
    pub const arm64_reg_ARM64_REG_H28: root::arm64_reg = 101;
    pub const arm64_reg_ARM64_REG_H29: root::arm64_reg = 102;
    pub const arm64_reg_ARM64_REG_H30: root::arm64_reg = 103;
    pub const arm64_reg_ARM64_REG_H31: root::arm64_reg = 104;
    pub const arm64_reg_ARM64_REG_P0: root::arm64_reg = 105;
    pub const arm64_reg_ARM64_REG_P1: root::arm64_reg = 106;
    pub const arm64_reg_ARM64_REG_P2: root::arm64_reg = 107;
    pub const arm64_reg_ARM64_REG_P3: root::arm64_reg = 108;
    pub const arm64_reg_ARM64_REG_P4: root::arm64_reg = 109;
    pub const arm64_reg_ARM64_REG_P5: root::arm64_reg = 110;
    pub const arm64_reg_ARM64_REG_P6: root::arm64_reg = 111;
    pub const arm64_reg_ARM64_REG_P7: root::arm64_reg = 112;
    pub const arm64_reg_ARM64_REG_P8: root::arm64_reg = 113;
    pub const arm64_reg_ARM64_REG_P9: root::arm64_reg = 114;
    pub const arm64_reg_ARM64_REG_P10: root::arm64_reg = 115;
    pub const arm64_reg_ARM64_REG_P11: root::arm64_reg = 116;
    pub const arm64_reg_ARM64_REG_P12: root::arm64_reg = 117;
    pub const arm64_reg_ARM64_REG_P13: root::arm64_reg = 118;
    pub const arm64_reg_ARM64_REG_P14: root::arm64_reg = 119;
    pub const arm64_reg_ARM64_REG_P15: root::arm64_reg = 120;
    pub const arm64_reg_ARM64_REG_Q0: root::arm64_reg = 121;
    pub const arm64_reg_ARM64_REG_Q1: root::arm64_reg = 122;
    pub const arm64_reg_ARM64_REG_Q2: root::arm64_reg = 123;
    pub const arm64_reg_ARM64_REG_Q3: root::arm64_reg = 124;
    pub const arm64_reg_ARM64_REG_Q4: root::arm64_reg = 125;
    pub const arm64_reg_ARM64_REG_Q5: root::arm64_reg = 126;
    pub const arm64_reg_ARM64_REG_Q6: root::arm64_reg = 127;
    pub const arm64_reg_ARM64_REG_Q7: root::arm64_reg = 128;
    pub const arm64_reg_ARM64_REG_Q8: root::arm64_reg = 129;
    pub const arm64_reg_ARM64_REG_Q9: root::arm64_reg = 130;
    pub const arm64_reg_ARM64_REG_Q10: root::arm64_reg = 131;
    pub const arm64_reg_ARM64_REG_Q11: root::arm64_reg = 132;
    pub const arm64_reg_ARM64_REG_Q12: root::arm64_reg = 133;
    pub const arm64_reg_ARM64_REG_Q13: root::arm64_reg = 134;
    pub const arm64_reg_ARM64_REG_Q14: root::arm64_reg = 135;
    pub const arm64_reg_ARM64_REG_Q15: root::arm64_reg = 136;
    pub const arm64_reg_ARM64_REG_Q16: root::arm64_reg = 137;
    pub const arm64_reg_ARM64_REG_Q17: root::arm64_reg = 138;
    pub const arm64_reg_ARM64_REG_Q18: root::arm64_reg = 139;
    pub const arm64_reg_ARM64_REG_Q19: root::arm64_reg = 140;
    pub const arm64_reg_ARM64_REG_Q20: root::arm64_reg = 141;
    pub const arm64_reg_ARM64_REG_Q21: root::arm64_reg = 142;
    pub const arm64_reg_ARM64_REG_Q22: root::arm64_reg = 143;
    pub const arm64_reg_ARM64_REG_Q23: root::arm64_reg = 144;
    pub const arm64_reg_ARM64_REG_Q24: root::arm64_reg = 145;
    pub const arm64_reg_ARM64_REG_Q25: root::arm64_reg = 146;
    pub const arm64_reg_ARM64_REG_Q26: root::arm64_reg = 147;
    pub const arm64_reg_ARM64_REG_Q27: root::arm64_reg = 148;
    pub const arm64_reg_ARM64_REG_Q28: root::arm64_reg = 149;
    pub const arm64_reg_ARM64_REG_Q29: root::arm64_reg = 150;
    pub const arm64_reg_ARM64_REG_Q30: root::arm64_reg = 151;
    pub const arm64_reg_ARM64_REG_Q31: root::arm64_reg = 152;
    pub const arm64_reg_ARM64_REG_S0: root::arm64_reg = 153;
    pub const arm64_reg_ARM64_REG_S1: root::arm64_reg = 154;
    pub const arm64_reg_ARM64_REG_S2: root::arm64_reg = 155;
    pub const arm64_reg_ARM64_REG_S3: root::arm64_reg = 156;
    pub const arm64_reg_ARM64_REG_S4: root::arm64_reg = 157;
    pub const arm64_reg_ARM64_REG_S5: root::arm64_reg = 158;
    pub const arm64_reg_ARM64_REG_S6: root::arm64_reg = 159;
    pub const arm64_reg_ARM64_REG_S7: root::arm64_reg = 160;
    pub const arm64_reg_ARM64_REG_S8: root::arm64_reg = 161;
    pub const arm64_reg_ARM64_REG_S9: root::arm64_reg = 162;
    pub const arm64_reg_ARM64_REG_S10: root::arm64_reg = 163;
    pub const arm64_reg_ARM64_REG_S11: root::arm64_reg = 164;
    pub const arm64_reg_ARM64_REG_S12: root::arm64_reg = 165;
    pub const arm64_reg_ARM64_REG_S13: root::arm64_reg = 166;
    pub const arm64_reg_ARM64_REG_S14: root::arm64_reg = 167;
    pub const arm64_reg_ARM64_REG_S15: root::arm64_reg = 168;
    pub const arm64_reg_ARM64_REG_S16: root::arm64_reg = 169;
    pub const arm64_reg_ARM64_REG_S17: root::arm64_reg = 170;
    pub const arm64_reg_ARM64_REG_S18: root::arm64_reg = 171;
    pub const arm64_reg_ARM64_REG_S19: root::arm64_reg = 172;
    pub const arm64_reg_ARM64_REG_S20: root::arm64_reg = 173;
    pub const arm64_reg_ARM64_REG_S21: root::arm64_reg = 174;
    pub const arm64_reg_ARM64_REG_S22: root::arm64_reg = 175;
    pub const arm64_reg_ARM64_REG_S23: root::arm64_reg = 176;
    pub const arm64_reg_ARM64_REG_S24: root::arm64_reg = 177;
    pub const arm64_reg_ARM64_REG_S25: root::arm64_reg = 178;
    pub const arm64_reg_ARM64_REG_S26: root::arm64_reg = 179;
    pub const arm64_reg_ARM64_REG_S27: root::arm64_reg = 180;
    pub const arm64_reg_ARM64_REG_S28: root::arm64_reg = 181;
    pub const arm64_reg_ARM64_REG_S29: root::arm64_reg = 182;
    pub const arm64_reg_ARM64_REG_S30: root::arm64_reg = 183;
    pub const arm64_reg_ARM64_REG_S31: root::arm64_reg = 184;
    pub const arm64_reg_ARM64_REG_W0: root::arm64_reg = 185;
    pub const arm64_reg_ARM64_REG_W1: root::arm64_reg = 186;
    pub const arm64_reg_ARM64_REG_W2: root::arm64_reg = 187;
    pub const arm64_reg_ARM64_REG_W3: root::arm64_reg = 188;
    pub const arm64_reg_ARM64_REG_W4: root::arm64_reg = 189;
    pub const arm64_reg_ARM64_REG_W5: root::arm64_reg = 190;
    pub const arm64_reg_ARM64_REG_W6: root::arm64_reg = 191;
    pub const arm64_reg_ARM64_REG_W7: root::arm64_reg = 192;
    pub const arm64_reg_ARM64_REG_W8: root::arm64_reg = 193;
    pub const arm64_reg_ARM64_REG_W9: root::arm64_reg = 194;
    pub const arm64_reg_ARM64_REG_W10: root::arm64_reg = 195;
    pub const arm64_reg_ARM64_REG_W11: root::arm64_reg = 196;
    pub const arm64_reg_ARM64_REG_W12: root::arm64_reg = 197;
    pub const arm64_reg_ARM64_REG_W13: root::arm64_reg = 198;
    pub const arm64_reg_ARM64_REG_W14: root::arm64_reg = 199;
    pub const arm64_reg_ARM64_REG_W15: root::arm64_reg = 200;
    pub const arm64_reg_ARM64_REG_W16: root::arm64_reg = 201;
    pub const arm64_reg_ARM64_REG_W17: root::arm64_reg = 202;
    pub const arm64_reg_ARM64_REG_W18: root::arm64_reg = 203;
    pub const arm64_reg_ARM64_REG_W19: root::arm64_reg = 204;
    pub const arm64_reg_ARM64_REG_W20: root::arm64_reg = 205;
    pub const arm64_reg_ARM64_REG_W21: root::arm64_reg = 206;
    pub const arm64_reg_ARM64_REG_W22: root::arm64_reg = 207;
    pub const arm64_reg_ARM64_REG_W23: root::arm64_reg = 208;
    pub const arm64_reg_ARM64_REG_W24: root::arm64_reg = 209;
    pub const arm64_reg_ARM64_REG_W25: root::arm64_reg = 210;
    pub const arm64_reg_ARM64_REG_W26: root::arm64_reg = 211;
    pub const arm64_reg_ARM64_REG_W27: root::arm64_reg = 212;
    pub const arm64_reg_ARM64_REG_W28: root::arm64_reg = 213;
    pub const arm64_reg_ARM64_REG_W29: root::arm64_reg = 214;
    pub const arm64_reg_ARM64_REG_W30: root::arm64_reg = 215;
    pub const arm64_reg_ARM64_REG_X0: root::arm64_reg = 216;
    pub const arm64_reg_ARM64_REG_X1: root::arm64_reg = 217;
    pub const arm64_reg_ARM64_REG_X2: root::arm64_reg = 218;
    pub const arm64_reg_ARM64_REG_X3: root::arm64_reg = 219;
    pub const arm64_reg_ARM64_REG_X4: root::arm64_reg = 220;
    pub const arm64_reg_ARM64_REG_X5: root::arm64_reg = 221;
    pub const arm64_reg_ARM64_REG_X6: root::arm64_reg = 222;
    pub const arm64_reg_ARM64_REG_X7: root::arm64_reg = 223;
    pub const arm64_reg_ARM64_REG_X8: root::arm64_reg = 224;
    pub const arm64_reg_ARM64_REG_X9: root::arm64_reg = 225;
    pub const arm64_reg_ARM64_REG_X10: root::arm64_reg = 226;
    pub const arm64_reg_ARM64_REG_X11: root::arm64_reg = 227;
    pub const arm64_reg_ARM64_REG_X12: root::arm64_reg = 228;
    pub const arm64_reg_ARM64_REG_X13: root::arm64_reg = 229;
    pub const arm64_reg_ARM64_REG_X14: root::arm64_reg = 230;
    pub const arm64_reg_ARM64_REG_X15: root::arm64_reg = 231;
    pub const arm64_reg_ARM64_REG_X16: root::arm64_reg = 232;
    pub const arm64_reg_ARM64_REG_X17: root::arm64_reg = 233;
    pub const arm64_reg_ARM64_REG_X18: root::arm64_reg = 234;
    pub const arm64_reg_ARM64_REG_X19: root::arm64_reg = 235;
    pub const arm64_reg_ARM64_REG_X20: root::arm64_reg = 236;
    pub const arm64_reg_ARM64_REG_X21: root::arm64_reg = 237;
    pub const arm64_reg_ARM64_REG_X22: root::arm64_reg = 238;
    pub const arm64_reg_ARM64_REG_X23: root::arm64_reg = 239;
    pub const arm64_reg_ARM64_REG_X24: root::arm64_reg = 240;
    pub const arm64_reg_ARM64_REG_X25: root::arm64_reg = 241;
    pub const arm64_reg_ARM64_REG_X26: root::arm64_reg = 242;
    pub const arm64_reg_ARM64_REG_X27: root::arm64_reg = 243;
    pub const arm64_reg_ARM64_REG_X28: root::arm64_reg = 244;
    pub const arm64_reg_ARM64_REG_Z0: root::arm64_reg = 245;
    pub const arm64_reg_ARM64_REG_Z1: root::arm64_reg = 246;
    pub const arm64_reg_ARM64_REG_Z2: root::arm64_reg = 247;
    pub const arm64_reg_ARM64_REG_Z3: root::arm64_reg = 248;
    pub const arm64_reg_ARM64_REG_Z4: root::arm64_reg = 249;
    pub const arm64_reg_ARM64_REG_Z5: root::arm64_reg = 250;
    pub const arm64_reg_ARM64_REG_Z6: root::arm64_reg = 251;
    pub const arm64_reg_ARM64_REG_Z7: root::arm64_reg = 252;
    pub const arm64_reg_ARM64_REG_Z8: root::arm64_reg = 253;
    pub const arm64_reg_ARM64_REG_Z9: root::arm64_reg = 254;
    pub const arm64_reg_ARM64_REG_Z10: root::arm64_reg = 255;
    pub const arm64_reg_ARM64_REG_Z11: root::arm64_reg = 256;
    pub const arm64_reg_ARM64_REG_Z12: root::arm64_reg = 257;
    pub const arm64_reg_ARM64_REG_Z13: root::arm64_reg = 258;
    pub const arm64_reg_ARM64_REG_Z14: root::arm64_reg = 259;
    pub const arm64_reg_ARM64_REG_Z15: root::arm64_reg = 260;
    pub const arm64_reg_ARM64_REG_Z16: root::arm64_reg = 261;
    pub const arm64_reg_ARM64_REG_Z17: root::arm64_reg = 262;
    pub const arm64_reg_ARM64_REG_Z18: root::arm64_reg = 263;
    pub const arm64_reg_ARM64_REG_Z19: root::arm64_reg = 264;
    pub const arm64_reg_ARM64_REG_Z20: root::arm64_reg = 265;
    pub const arm64_reg_ARM64_REG_Z21: root::arm64_reg = 266;
    pub const arm64_reg_ARM64_REG_Z22: root::arm64_reg = 267;
    pub const arm64_reg_ARM64_REG_Z23: root::arm64_reg = 268;
    pub const arm64_reg_ARM64_REG_Z24: root::arm64_reg = 269;
    pub const arm64_reg_ARM64_REG_Z25: root::arm64_reg = 270;
    pub const arm64_reg_ARM64_REG_Z26: root::arm64_reg = 271;
    pub const arm64_reg_ARM64_REG_Z27: root::arm64_reg = 272;
    pub const arm64_reg_ARM64_REG_Z28: root::arm64_reg = 273;
    pub const arm64_reg_ARM64_REG_Z29: root::arm64_reg = 274;
    pub const arm64_reg_ARM64_REG_Z30: root::arm64_reg = 275;
    pub const arm64_reg_ARM64_REG_Z31: root::arm64_reg = 276;
    pub const arm64_reg_ARM64_REG_V0: root::arm64_reg = 277;
    pub const arm64_reg_ARM64_REG_V1: root::arm64_reg = 278;
    pub const arm64_reg_ARM64_REG_V2: root::arm64_reg = 279;
    pub const arm64_reg_ARM64_REG_V3: root::arm64_reg = 280;
    pub const arm64_reg_ARM64_REG_V4: root::arm64_reg = 281;
    pub const arm64_reg_ARM64_REG_V5: root::arm64_reg = 282;
    pub const arm64_reg_ARM64_REG_V6: root::arm64_reg = 283;
    pub const arm64_reg_ARM64_REG_V7: root::arm64_reg = 284;
    pub const arm64_reg_ARM64_REG_V8: root::arm64_reg = 285;
    pub const arm64_reg_ARM64_REG_V9: root::arm64_reg = 286;
    pub const arm64_reg_ARM64_REG_V10: root::arm64_reg = 287;
    pub const arm64_reg_ARM64_REG_V11: root::arm64_reg = 288;
    pub const arm64_reg_ARM64_REG_V12: root::arm64_reg = 289;
    pub const arm64_reg_ARM64_REG_V13: root::arm64_reg = 290;
    pub const arm64_reg_ARM64_REG_V14: root::arm64_reg = 291;
    pub const arm64_reg_ARM64_REG_V15: root::arm64_reg = 292;
    pub const arm64_reg_ARM64_REG_V16: root::arm64_reg = 293;
    pub const arm64_reg_ARM64_REG_V17: root::arm64_reg = 294;
    pub const arm64_reg_ARM64_REG_V18: root::arm64_reg = 295;
    pub const arm64_reg_ARM64_REG_V19: root::arm64_reg = 296;
    pub const arm64_reg_ARM64_REG_V20: root::arm64_reg = 297;
    pub const arm64_reg_ARM64_REG_V21: root::arm64_reg = 298;
    pub const arm64_reg_ARM64_REG_V22: root::arm64_reg = 299;
    pub const arm64_reg_ARM64_REG_V23: root::arm64_reg = 300;
    pub const arm64_reg_ARM64_REG_V24: root::arm64_reg = 301;
    pub const arm64_reg_ARM64_REG_V25: root::arm64_reg = 302;
    pub const arm64_reg_ARM64_REG_V26: root::arm64_reg = 303;
    pub const arm64_reg_ARM64_REG_V27: root::arm64_reg = 304;
    pub const arm64_reg_ARM64_REG_V28: root::arm64_reg = 305;
    pub const arm64_reg_ARM64_REG_V29: root::arm64_reg = 306;
    pub const arm64_reg_ARM64_REG_V30: root::arm64_reg = 307;
    pub const arm64_reg_ARM64_REG_V31: root::arm64_reg = 308;
    pub const arm64_reg_ARM64_REG_ENDING: root::arm64_reg = 309;
    pub const arm64_reg_ARM64_REG_IP0: root::arm64_reg = 232;
    pub const arm64_reg_ARM64_REG_IP1: root::arm64_reg = 233;
    pub const arm64_reg_ARM64_REG_X29: root::arm64_reg = 2;
    pub const arm64_reg_ARM64_REG_X30: root::arm64_reg = 3;
    #[doc = " ARM64 registers"]
    pub type arm64_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with ARM64_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct arm64_op_mem {
        #[doc = "< base register"]
        pub base: root::arm64_reg,
        #[doc = "< index register"]
        pub index: root::arm64_reg,
        #[doc = "< displacement/offset value"]
        pub disp: i32,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_arm64_op {
        #[doc = "< Vector Index for some vector operands (or -1 if irrelevant)"]
        pub vector_index: cty::c_int,
        #[doc = "< Vector Arrangement Specifier"]
        pub vas: root::arm64_vas,
        pub shift: root::cs_arm64_op__bindgen_ty_1,
        #[doc = "< extender type of this operand"]
        pub ext: root::arm64_extender,
        #[doc = "< operand type"]
        pub type_: root::arm64_op_type,
        pub __bindgen_anon_1: root::cs_arm64_op__bindgen_ty_2,
        #[doc = " How is this operand accessed? (READ, WRITE or READ|WRITE)"]
        #[doc = " This field is combined of cs_ac_type."]
        #[doc = " NOTE: this field is irrelevant if engine is compiled in DIET mode."]
        pub access: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_arm64_op__bindgen_ty_1 {
        #[doc = "< shifter type of this operand"]
        pub type_: root::arm64_shifter,
        #[doc = "< shifter value of this operand"]
        pub value: cty::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_arm64_op__bindgen_ty_2 {
        #[doc = "< register value for REG operand"]
        pub reg: root::arm64_reg,
        #[doc = "< immediate value, or index for C-IMM or IMM operand"]
        pub imm: i64,
        #[doc = "< floating point value for FP operand"]
        pub fp: f64,
        #[doc = "< base/index/scale/disp value for MEM operand"]
        pub mem: root::arm64_op_mem,
        #[doc = "< PState field of MSR instruction."]
        pub pstate: root::arm64_pstate,
        #[doc = "< IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)"]
        pub sys: root::arm64_sys_op,
        #[doc = "< PRFM operation."]
        pub prefetch: root::arm64_prefetch_op,
        #[doc = "< Memory barrier operation (ISB/DMB/DSB instructions)."]
        pub barrier: root::arm64_barrier_op,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_arm64 {
        #[doc = "< conditional code for this insn"]
        pub cc: root::arm64_cc,
        #[doc = "< does this insn update flags?"]
        pub update_flags: bool,
        #[doc = "< does this insn request writeback? 'True' means 'yes'"]
        pub writeback: bool,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_arm64_op; 8usize],
    }
    pub const m68k_reg_M68K_REG_INVALID: root::m68k_reg = 0;
    pub const m68k_reg_M68K_REG_D0: root::m68k_reg = 1;
    pub const m68k_reg_M68K_REG_D1: root::m68k_reg = 2;
    pub const m68k_reg_M68K_REG_D2: root::m68k_reg = 3;
    pub const m68k_reg_M68K_REG_D3: root::m68k_reg = 4;
    pub const m68k_reg_M68K_REG_D4: root::m68k_reg = 5;
    pub const m68k_reg_M68K_REG_D5: root::m68k_reg = 6;
    pub const m68k_reg_M68K_REG_D6: root::m68k_reg = 7;
    pub const m68k_reg_M68K_REG_D7: root::m68k_reg = 8;
    pub const m68k_reg_M68K_REG_A0: root::m68k_reg = 9;
    pub const m68k_reg_M68K_REG_A1: root::m68k_reg = 10;
    pub const m68k_reg_M68K_REG_A2: root::m68k_reg = 11;
    pub const m68k_reg_M68K_REG_A3: root::m68k_reg = 12;
    pub const m68k_reg_M68K_REG_A4: root::m68k_reg = 13;
    pub const m68k_reg_M68K_REG_A5: root::m68k_reg = 14;
    pub const m68k_reg_M68K_REG_A6: root::m68k_reg = 15;
    pub const m68k_reg_M68K_REG_A7: root::m68k_reg = 16;
    pub const m68k_reg_M68K_REG_FP0: root::m68k_reg = 17;
    pub const m68k_reg_M68K_REG_FP1: root::m68k_reg = 18;
    pub const m68k_reg_M68K_REG_FP2: root::m68k_reg = 19;
    pub const m68k_reg_M68K_REG_FP3: root::m68k_reg = 20;
    pub const m68k_reg_M68K_REG_FP4: root::m68k_reg = 21;
    pub const m68k_reg_M68K_REG_FP5: root::m68k_reg = 22;
    pub const m68k_reg_M68K_REG_FP6: root::m68k_reg = 23;
    pub const m68k_reg_M68K_REG_FP7: root::m68k_reg = 24;
    pub const m68k_reg_M68K_REG_PC: root::m68k_reg = 25;
    pub const m68k_reg_M68K_REG_SR: root::m68k_reg = 26;
    pub const m68k_reg_M68K_REG_CCR: root::m68k_reg = 27;
    pub const m68k_reg_M68K_REG_SFC: root::m68k_reg = 28;
    pub const m68k_reg_M68K_REG_DFC: root::m68k_reg = 29;
    pub const m68k_reg_M68K_REG_USP: root::m68k_reg = 30;
    pub const m68k_reg_M68K_REG_VBR: root::m68k_reg = 31;
    pub const m68k_reg_M68K_REG_CACR: root::m68k_reg = 32;
    pub const m68k_reg_M68K_REG_CAAR: root::m68k_reg = 33;
    pub const m68k_reg_M68K_REG_MSP: root::m68k_reg = 34;
    pub const m68k_reg_M68K_REG_ISP: root::m68k_reg = 35;
    pub const m68k_reg_M68K_REG_TC: root::m68k_reg = 36;
    pub const m68k_reg_M68K_REG_ITT0: root::m68k_reg = 37;
    pub const m68k_reg_M68K_REG_ITT1: root::m68k_reg = 38;
    pub const m68k_reg_M68K_REG_DTT0: root::m68k_reg = 39;
    pub const m68k_reg_M68K_REG_DTT1: root::m68k_reg = 40;
    pub const m68k_reg_M68K_REG_MMUSR: root::m68k_reg = 41;
    pub const m68k_reg_M68K_REG_URP: root::m68k_reg = 42;
    pub const m68k_reg_M68K_REG_SRP: root::m68k_reg = 43;
    pub const m68k_reg_M68K_REG_FPCR: root::m68k_reg = 44;
    pub const m68k_reg_M68K_REG_FPSR: root::m68k_reg = 45;
    pub const m68k_reg_M68K_REG_FPIAR: root::m68k_reg = 46;
    pub const m68k_reg_M68K_REG_ENDING: root::m68k_reg = 47;
    #[doc = " M68K registers and special registers"]
    pub type m68k_reg = cty::c_int;
    #[doc = "< No address mode."]
    pub const m68k_address_mode_M68K_AM_NONE: root::m68k_address_mode = 0;
    #[doc = "< Register Direct - Data"]
    pub const m68k_address_mode_M68K_AM_REG_DIRECT_DATA: root::m68k_address_mode = 1;
    #[doc = "< Register Direct - Address"]
    pub const m68k_address_mode_M68K_AM_REG_DIRECT_ADDR: root::m68k_address_mode = 2;
    #[doc = "< Register Indirect - Address"]
    pub const m68k_address_mode_M68K_AM_REGI_ADDR: root::m68k_address_mode = 3;
    #[doc = "< Register Indirect - Address with Postincrement"]
    pub const m68k_address_mode_M68K_AM_REGI_ADDR_POST_INC: root::m68k_address_mode = 4;
    #[doc = "< Register Indirect - Address with Predecrement"]
    pub const m68k_address_mode_M68K_AM_REGI_ADDR_PRE_DEC: root::m68k_address_mode = 5;
    #[doc = "< Register Indirect - Address with Displacement"]
    pub const m68k_address_mode_M68K_AM_REGI_ADDR_DISP: root::m68k_address_mode = 6;
    #[doc = "< Address Register Indirect With Index- 8-bit displacement"]
    pub const m68k_address_mode_M68K_AM_AREGI_INDEX_8_BIT_DISP: root::m68k_address_mode = 7;
    #[doc = "< Address Register Indirect With Index- Base displacement"]
    pub const m68k_address_mode_M68K_AM_AREGI_INDEX_BASE_DISP: root::m68k_address_mode = 8;
    #[doc = "< Memory indirect - Postindex"]
    pub const m68k_address_mode_M68K_AM_MEMI_POST_INDEX: root::m68k_address_mode = 9;
    #[doc = "< Memory indirect - Preindex"]
    pub const m68k_address_mode_M68K_AM_MEMI_PRE_INDEX: root::m68k_address_mode = 10;
    #[doc = "< Program Counter Indirect - with Displacement"]
    pub const m68k_address_mode_M68K_AM_PCI_DISP: root::m68k_address_mode = 11;
    #[doc = "< Program Counter Indirect with Index - with 8-Bit Displacement"]
    pub const m68k_address_mode_M68K_AM_PCI_INDEX_8_BIT_DISP: root::m68k_address_mode = 12;
    #[doc = "< Program Counter Indirect with Index - with Base Displacement"]
    pub const m68k_address_mode_M68K_AM_PCI_INDEX_BASE_DISP: root::m68k_address_mode = 13;
    #[doc = "< Program Counter Memory Indirect - Postindexed"]
    pub const m68k_address_mode_M68K_AM_PC_MEMI_POST_INDEX: root::m68k_address_mode = 14;
    #[doc = "< Program Counter Memory Indirect - Preindexed"]
    pub const m68k_address_mode_M68K_AM_PC_MEMI_PRE_INDEX: root::m68k_address_mode = 15;
    #[doc = "< Absolute Data Addressing  - Short"]
    pub const m68k_address_mode_M68K_AM_ABSOLUTE_DATA_SHORT: root::m68k_address_mode = 16;
    #[doc = "< Absolute Data Addressing  - Long"]
    pub const m68k_address_mode_M68K_AM_ABSOLUTE_DATA_LONG: root::m68k_address_mode = 17;
    #[doc = "< Immediate value"]
    pub const m68k_address_mode_M68K_AM_IMMEDIATE: root::m68k_address_mode = 18;
    #[doc = "< Address as displacement from (PC+2) used by branches"]
    pub const m68k_address_mode_M68K_AM_BRANCH_DISPLACEMENT: root::m68k_address_mode = 19;
    #[doc = " M68K Addressing Modes"]
    pub type m68k_address_mode = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const m68k_op_type_M68K_OP_INVALID: root::m68k_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const m68k_op_type_M68K_OP_REG: root::m68k_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const m68k_op_type_M68K_OP_IMM: root::m68k_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const m68k_op_type_M68K_OP_MEM: root::m68k_op_type = 3;
    #[doc = "< single precision Floating-Point operand"]
    pub const m68k_op_type_M68K_OP_FP_SINGLE: root::m68k_op_type = 4;
    #[doc = "< double precision Floating-Point operand"]
    pub const m68k_op_type_M68K_OP_FP_DOUBLE: root::m68k_op_type = 5;
    #[doc = "< Register bits move"]
    pub const m68k_op_type_M68K_OP_REG_BITS: root::m68k_op_type = 6;
    #[doc = "< Register pair in the same op (upper 4 bits for first reg, lower for second)"]
    pub const m68k_op_type_M68K_OP_REG_PAIR: root::m68k_op_type = 7;
    #[doc = "< Branch displacement"]
    pub const m68k_op_type_M68K_OP_BR_DISP: root::m68k_op_type = 8;
    #[doc = " Operand type for instruction's operands"]
    pub type m68k_op_type = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with M68K_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct m68k_op_mem {
        #[doc = "< base register (or M68K_REG_INVALID if irrelevant)"]
        pub base_reg: root::m68k_reg,
        #[doc = "< index register (or M68K_REG_INVALID if irrelevant)"]
        pub index_reg: root::m68k_reg,
        #[doc = "< indirect base register (or M68K_REG_INVALID if irrelevant)"]
        pub in_base_reg: root::m68k_reg,
        #[doc = "< indirect displacement"]
        pub in_disp: u32,
        #[doc = "< other displacement"]
        pub out_disp: u32,
        #[doc = "< displacement value"]
        pub disp: i16,
        #[doc = "< scale for index register"]
        pub scale: u8,
        #[doc = "< set to true if the two values below should be used"]
        pub bitfield: u8,
        #[doc = "< used for bf* instructions"]
        pub width: u8,
        #[doc = "< used for bf* instructions"]
        pub offset: u8,
        #[doc = "< 0 = w, 1 = l"]
        pub index_size: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct m68k_op_br_disp {
        #[doc = "< displacement value"]
        pub disp: i32,
        #[doc = "< Size from m68k_op_br_disp_size type above"]
        pub disp_size: u8,
    }
    #[doc = " Register pair in one operand."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_m68k_op_reg_pair {
        pub reg_0: root::m68k_reg,
        pub reg_1: root::m68k_reg,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_m68k_op {
        pub __bindgen_anon_1: root::cs_m68k_op__bindgen_ty_1,
        #[doc = "< data when operand is targeting memory"]
        pub mem: root::m68k_op_mem,
        #[doc = "< data when operand is a branch displacement"]
        pub br_disp: root::m68k_op_br_disp,
        #[doc = "< register bits for movem etc. (always in d0-d7, a0-a7, fp0 - fp7 order)"]
        pub register_bits: u32,
        pub type_: root::m68k_op_type,
        #[doc = "< M68K addressing mode for this op"]
        pub address_mode: root::m68k_address_mode,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_m68k_op__bindgen_ty_1 {
        #[doc = "< immediate value for IMM operand"]
        pub imm: u64,
        #[doc = "< double imm"]
        pub dimm: f64,
        #[doc = "< float imm"]
        pub simm: f32,
        #[doc = "< register value for REG operand"]
        pub reg: root::m68k_reg,
        #[doc = "< register pair in one operand"]
        pub reg_pair: root::cs_m68k_op_reg_pair,
    }
    #[doc = "< unsized or unspecified"]
    pub const m68k_cpu_size_M68K_CPU_SIZE_NONE: root::m68k_cpu_size = 0;
    #[doc = "< 1 byte in size"]
    pub const m68k_cpu_size_M68K_CPU_SIZE_BYTE: root::m68k_cpu_size = 1;
    #[doc = "< 2 bytes in size"]
    pub const m68k_cpu_size_M68K_CPU_SIZE_WORD: root::m68k_cpu_size = 2;
    #[doc = "< 4 bytes in size"]
    pub const m68k_cpu_size_M68K_CPU_SIZE_LONG: root::m68k_cpu_size = 4;
    #[doc = " Operation size of the CPU instructions"]
    pub type m68k_cpu_size = cty::c_int;
    #[doc = "< unsized like fsave/frestore"]
    pub const m68k_fpu_size_M68K_FPU_SIZE_NONE: root::m68k_fpu_size = 0;
    #[doc = "< 4 byte in size (single float)"]
    pub const m68k_fpu_size_M68K_FPU_SIZE_SINGLE: root::m68k_fpu_size = 4;
    #[doc = "< 8 byte in size (double)"]
    pub const m68k_fpu_size_M68K_FPU_SIZE_DOUBLE: root::m68k_fpu_size = 8;
    #[doc = "< 12 byte in size (extended real format)"]
    pub const m68k_fpu_size_M68K_FPU_SIZE_EXTENDED: root::m68k_fpu_size = 12;
    #[doc = " Operation size of the FPU instructions (Notice that FPU instruction can also use CPU sizes if needed)"]
    pub type m68k_fpu_size = cty::c_int;
    pub const m68k_size_type_M68K_SIZE_TYPE_INVALID: root::m68k_size_type = 0;
    pub const m68k_size_type_M68K_SIZE_TYPE_CPU: root::m68k_size_type = 1;
    pub const m68k_size_type_M68K_SIZE_TYPE_FPU: root::m68k_size_type = 2;
    #[doc = " Type of size that is being used for the current instruction"]
    pub type m68k_size_type = cty::c_int;
    #[doc = " Operation size of the current instruction (NOT the actually size of instruction)"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct m68k_op_size {
        pub type_: root::m68k_size_type,
        pub __bindgen_anon_1: root::m68k_op_size__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union m68k_op_size__bindgen_ty_1 {
        pub cpu_size: root::m68k_cpu_size,
        pub fpu_size: root::m68k_fpu_size,
    }
    #[doc = " The M68K instruction and it's operands"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_m68k {
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_m68k_op; 4usize],
        #[doc = "< size of data operand works on in bytes (.b, .w, .l, etc)"]
        pub op_size: root::m68k_op_size,
        #[doc = "< number of operands for the instruction"]
        pub op_count: u8,
    }
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const mips_op_type_MIPS_OP_INVALID: root::mips_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const mips_op_type_MIPS_OP_REG: root::mips_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const mips_op_type_MIPS_OP_IMM: root::mips_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const mips_op_type_MIPS_OP_MEM: root::mips_op_type = 3;
    #[doc = " Operand type for instruction's operands"]
    pub type mips_op_type = cty::c_int;
    pub const mips_reg_MIPS_REG_INVALID: root::mips_reg = 0;
    pub const mips_reg_MIPS_REG_PC: root::mips_reg = 1;
    pub const mips_reg_MIPS_REG_0: root::mips_reg = 2;
    pub const mips_reg_MIPS_REG_1: root::mips_reg = 3;
    pub const mips_reg_MIPS_REG_2: root::mips_reg = 4;
    pub const mips_reg_MIPS_REG_3: root::mips_reg = 5;
    pub const mips_reg_MIPS_REG_4: root::mips_reg = 6;
    pub const mips_reg_MIPS_REG_5: root::mips_reg = 7;
    pub const mips_reg_MIPS_REG_6: root::mips_reg = 8;
    pub const mips_reg_MIPS_REG_7: root::mips_reg = 9;
    pub const mips_reg_MIPS_REG_8: root::mips_reg = 10;
    pub const mips_reg_MIPS_REG_9: root::mips_reg = 11;
    pub const mips_reg_MIPS_REG_10: root::mips_reg = 12;
    pub const mips_reg_MIPS_REG_11: root::mips_reg = 13;
    pub const mips_reg_MIPS_REG_12: root::mips_reg = 14;
    pub const mips_reg_MIPS_REG_13: root::mips_reg = 15;
    pub const mips_reg_MIPS_REG_14: root::mips_reg = 16;
    pub const mips_reg_MIPS_REG_15: root::mips_reg = 17;
    pub const mips_reg_MIPS_REG_16: root::mips_reg = 18;
    pub const mips_reg_MIPS_REG_17: root::mips_reg = 19;
    pub const mips_reg_MIPS_REG_18: root::mips_reg = 20;
    pub const mips_reg_MIPS_REG_19: root::mips_reg = 21;
    pub const mips_reg_MIPS_REG_20: root::mips_reg = 22;
    pub const mips_reg_MIPS_REG_21: root::mips_reg = 23;
    pub const mips_reg_MIPS_REG_22: root::mips_reg = 24;
    pub const mips_reg_MIPS_REG_23: root::mips_reg = 25;
    pub const mips_reg_MIPS_REG_24: root::mips_reg = 26;
    pub const mips_reg_MIPS_REG_25: root::mips_reg = 27;
    pub const mips_reg_MIPS_REG_26: root::mips_reg = 28;
    pub const mips_reg_MIPS_REG_27: root::mips_reg = 29;
    pub const mips_reg_MIPS_REG_28: root::mips_reg = 30;
    pub const mips_reg_MIPS_REG_29: root::mips_reg = 31;
    pub const mips_reg_MIPS_REG_30: root::mips_reg = 32;
    pub const mips_reg_MIPS_REG_31: root::mips_reg = 33;
    pub const mips_reg_MIPS_REG_DSPCCOND: root::mips_reg = 34;
    pub const mips_reg_MIPS_REG_DSPCARRY: root::mips_reg = 35;
    pub const mips_reg_MIPS_REG_DSPEFI: root::mips_reg = 36;
    pub const mips_reg_MIPS_REG_DSPOUTFLAG: root::mips_reg = 37;
    pub const mips_reg_MIPS_REG_DSPOUTFLAG16_19: root::mips_reg = 38;
    pub const mips_reg_MIPS_REG_DSPOUTFLAG20: root::mips_reg = 39;
    pub const mips_reg_MIPS_REG_DSPOUTFLAG21: root::mips_reg = 40;
    pub const mips_reg_MIPS_REG_DSPOUTFLAG22: root::mips_reg = 41;
    pub const mips_reg_MIPS_REG_DSPOUTFLAG23: root::mips_reg = 42;
    pub const mips_reg_MIPS_REG_DSPPOS: root::mips_reg = 43;
    pub const mips_reg_MIPS_REG_DSPSCOUNT: root::mips_reg = 44;
    pub const mips_reg_MIPS_REG_AC0: root::mips_reg = 45;
    pub const mips_reg_MIPS_REG_AC1: root::mips_reg = 46;
    pub const mips_reg_MIPS_REG_AC2: root::mips_reg = 47;
    pub const mips_reg_MIPS_REG_AC3: root::mips_reg = 48;
    pub const mips_reg_MIPS_REG_CC0: root::mips_reg = 49;
    pub const mips_reg_MIPS_REG_CC1: root::mips_reg = 50;
    pub const mips_reg_MIPS_REG_CC2: root::mips_reg = 51;
    pub const mips_reg_MIPS_REG_CC3: root::mips_reg = 52;
    pub const mips_reg_MIPS_REG_CC4: root::mips_reg = 53;
    pub const mips_reg_MIPS_REG_CC5: root::mips_reg = 54;
    pub const mips_reg_MIPS_REG_CC6: root::mips_reg = 55;
    pub const mips_reg_MIPS_REG_CC7: root::mips_reg = 56;
    pub const mips_reg_MIPS_REG_F0: root::mips_reg = 57;
    pub const mips_reg_MIPS_REG_F1: root::mips_reg = 58;
    pub const mips_reg_MIPS_REG_F2: root::mips_reg = 59;
    pub const mips_reg_MIPS_REG_F3: root::mips_reg = 60;
    pub const mips_reg_MIPS_REG_F4: root::mips_reg = 61;
    pub const mips_reg_MIPS_REG_F5: root::mips_reg = 62;
    pub const mips_reg_MIPS_REG_F6: root::mips_reg = 63;
    pub const mips_reg_MIPS_REG_F7: root::mips_reg = 64;
    pub const mips_reg_MIPS_REG_F8: root::mips_reg = 65;
    pub const mips_reg_MIPS_REG_F9: root::mips_reg = 66;
    pub const mips_reg_MIPS_REG_F10: root::mips_reg = 67;
    pub const mips_reg_MIPS_REG_F11: root::mips_reg = 68;
    pub const mips_reg_MIPS_REG_F12: root::mips_reg = 69;
    pub const mips_reg_MIPS_REG_F13: root::mips_reg = 70;
    pub const mips_reg_MIPS_REG_F14: root::mips_reg = 71;
    pub const mips_reg_MIPS_REG_F15: root::mips_reg = 72;
    pub const mips_reg_MIPS_REG_F16: root::mips_reg = 73;
    pub const mips_reg_MIPS_REG_F17: root::mips_reg = 74;
    pub const mips_reg_MIPS_REG_F18: root::mips_reg = 75;
    pub const mips_reg_MIPS_REG_F19: root::mips_reg = 76;
    pub const mips_reg_MIPS_REG_F20: root::mips_reg = 77;
    pub const mips_reg_MIPS_REG_F21: root::mips_reg = 78;
    pub const mips_reg_MIPS_REG_F22: root::mips_reg = 79;
    pub const mips_reg_MIPS_REG_F23: root::mips_reg = 80;
    pub const mips_reg_MIPS_REG_F24: root::mips_reg = 81;
    pub const mips_reg_MIPS_REG_F25: root::mips_reg = 82;
    pub const mips_reg_MIPS_REG_F26: root::mips_reg = 83;
    pub const mips_reg_MIPS_REG_F27: root::mips_reg = 84;
    pub const mips_reg_MIPS_REG_F28: root::mips_reg = 85;
    pub const mips_reg_MIPS_REG_F29: root::mips_reg = 86;
    pub const mips_reg_MIPS_REG_F30: root::mips_reg = 87;
    pub const mips_reg_MIPS_REG_F31: root::mips_reg = 88;
    pub const mips_reg_MIPS_REG_FCC0: root::mips_reg = 89;
    pub const mips_reg_MIPS_REG_FCC1: root::mips_reg = 90;
    pub const mips_reg_MIPS_REG_FCC2: root::mips_reg = 91;
    pub const mips_reg_MIPS_REG_FCC3: root::mips_reg = 92;
    pub const mips_reg_MIPS_REG_FCC4: root::mips_reg = 93;
    pub const mips_reg_MIPS_REG_FCC5: root::mips_reg = 94;
    pub const mips_reg_MIPS_REG_FCC6: root::mips_reg = 95;
    pub const mips_reg_MIPS_REG_FCC7: root::mips_reg = 96;
    pub const mips_reg_MIPS_REG_W0: root::mips_reg = 97;
    pub const mips_reg_MIPS_REG_W1: root::mips_reg = 98;
    pub const mips_reg_MIPS_REG_W2: root::mips_reg = 99;
    pub const mips_reg_MIPS_REG_W3: root::mips_reg = 100;
    pub const mips_reg_MIPS_REG_W4: root::mips_reg = 101;
    pub const mips_reg_MIPS_REG_W5: root::mips_reg = 102;
    pub const mips_reg_MIPS_REG_W6: root::mips_reg = 103;
    pub const mips_reg_MIPS_REG_W7: root::mips_reg = 104;
    pub const mips_reg_MIPS_REG_W8: root::mips_reg = 105;
    pub const mips_reg_MIPS_REG_W9: root::mips_reg = 106;
    pub const mips_reg_MIPS_REG_W10: root::mips_reg = 107;
    pub const mips_reg_MIPS_REG_W11: root::mips_reg = 108;
    pub const mips_reg_MIPS_REG_W12: root::mips_reg = 109;
    pub const mips_reg_MIPS_REG_W13: root::mips_reg = 110;
    pub const mips_reg_MIPS_REG_W14: root::mips_reg = 111;
    pub const mips_reg_MIPS_REG_W15: root::mips_reg = 112;
    pub const mips_reg_MIPS_REG_W16: root::mips_reg = 113;
    pub const mips_reg_MIPS_REG_W17: root::mips_reg = 114;
    pub const mips_reg_MIPS_REG_W18: root::mips_reg = 115;
    pub const mips_reg_MIPS_REG_W19: root::mips_reg = 116;
    pub const mips_reg_MIPS_REG_W20: root::mips_reg = 117;
    pub const mips_reg_MIPS_REG_W21: root::mips_reg = 118;
    pub const mips_reg_MIPS_REG_W22: root::mips_reg = 119;
    pub const mips_reg_MIPS_REG_W23: root::mips_reg = 120;
    pub const mips_reg_MIPS_REG_W24: root::mips_reg = 121;
    pub const mips_reg_MIPS_REG_W25: root::mips_reg = 122;
    pub const mips_reg_MIPS_REG_W26: root::mips_reg = 123;
    pub const mips_reg_MIPS_REG_W27: root::mips_reg = 124;
    pub const mips_reg_MIPS_REG_W28: root::mips_reg = 125;
    pub const mips_reg_MIPS_REG_W29: root::mips_reg = 126;
    pub const mips_reg_MIPS_REG_W30: root::mips_reg = 127;
    pub const mips_reg_MIPS_REG_W31: root::mips_reg = 128;
    pub const mips_reg_MIPS_REG_HI: root::mips_reg = 129;
    pub const mips_reg_MIPS_REG_LO: root::mips_reg = 130;
    pub const mips_reg_MIPS_REG_P0: root::mips_reg = 131;
    pub const mips_reg_MIPS_REG_P1: root::mips_reg = 132;
    pub const mips_reg_MIPS_REG_P2: root::mips_reg = 133;
    pub const mips_reg_MIPS_REG_MPL0: root::mips_reg = 134;
    pub const mips_reg_MIPS_REG_MPL1: root::mips_reg = 135;
    pub const mips_reg_MIPS_REG_MPL2: root::mips_reg = 136;
    pub const mips_reg_MIPS_REG_ENDING: root::mips_reg = 137;
    pub const mips_reg_MIPS_REG_ZERO: root::mips_reg = 2;
    pub const mips_reg_MIPS_REG_AT: root::mips_reg = 3;
    pub const mips_reg_MIPS_REG_V0: root::mips_reg = 4;
    pub const mips_reg_MIPS_REG_V1: root::mips_reg = 5;
    pub const mips_reg_MIPS_REG_A0: root::mips_reg = 6;
    pub const mips_reg_MIPS_REG_A1: root::mips_reg = 7;
    pub const mips_reg_MIPS_REG_A2: root::mips_reg = 8;
    pub const mips_reg_MIPS_REG_A3: root::mips_reg = 9;
    pub const mips_reg_MIPS_REG_T0: root::mips_reg = 10;
    pub const mips_reg_MIPS_REG_T1: root::mips_reg = 11;
    pub const mips_reg_MIPS_REG_T2: root::mips_reg = 12;
    pub const mips_reg_MIPS_REG_T3: root::mips_reg = 13;
    pub const mips_reg_MIPS_REG_T4: root::mips_reg = 14;
    pub const mips_reg_MIPS_REG_T5: root::mips_reg = 15;
    pub const mips_reg_MIPS_REG_T6: root::mips_reg = 16;
    pub const mips_reg_MIPS_REG_T7: root::mips_reg = 17;
    pub const mips_reg_MIPS_REG_S0: root::mips_reg = 18;
    pub const mips_reg_MIPS_REG_S1: root::mips_reg = 19;
    pub const mips_reg_MIPS_REG_S2: root::mips_reg = 20;
    pub const mips_reg_MIPS_REG_S3: root::mips_reg = 21;
    pub const mips_reg_MIPS_REG_S4: root::mips_reg = 22;
    pub const mips_reg_MIPS_REG_S5: root::mips_reg = 23;
    pub const mips_reg_MIPS_REG_S6: root::mips_reg = 24;
    pub const mips_reg_MIPS_REG_S7: root::mips_reg = 25;
    pub const mips_reg_MIPS_REG_T8: root::mips_reg = 26;
    pub const mips_reg_MIPS_REG_T9: root::mips_reg = 27;
    pub const mips_reg_MIPS_REG_K0: root::mips_reg = 28;
    pub const mips_reg_MIPS_REG_K1: root::mips_reg = 29;
    pub const mips_reg_MIPS_REG_GP: root::mips_reg = 30;
    pub const mips_reg_MIPS_REG_SP: root::mips_reg = 31;
    pub const mips_reg_MIPS_REG_FP: root::mips_reg = 32;
    pub const mips_reg_MIPS_REG_S8: root::mips_reg = 32;
    pub const mips_reg_MIPS_REG_RA: root::mips_reg = 33;
    pub const mips_reg_MIPS_REG_HI0: root::mips_reg = 45;
    pub const mips_reg_MIPS_REG_HI1: root::mips_reg = 46;
    pub const mips_reg_MIPS_REG_HI2: root::mips_reg = 47;
    pub const mips_reg_MIPS_REG_HI3: root::mips_reg = 48;
    pub const mips_reg_MIPS_REG_LO0: root::mips_reg = 45;
    pub const mips_reg_MIPS_REG_LO1: root::mips_reg = 46;
    pub const mips_reg_MIPS_REG_LO2: root::mips_reg = 47;
    pub const mips_reg_MIPS_REG_LO3: root::mips_reg = 48;
    #[doc = " MIPS registers"]
    pub type mips_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with MIPS_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mips_op_mem {
        #[doc = "< base register"]
        pub base: root::mips_reg,
        #[doc = "< displacement/offset value"]
        pub disp: i64,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_mips_op {
        #[doc = "< operand type"]
        pub type_: root::mips_op_type,
        pub __bindgen_anon_1: root::cs_mips_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_mips_op__bindgen_ty_1 {
        #[doc = "< register id for REG operand"]
        pub reg: root::mips_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i64,
        #[doc = "< base/index/scale/disp value for MEM operand"]
        pub mem: root::mips_op_mem,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_mips {
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_mips_op; 10usize],
    }
    pub const ppc_bc_PPC_BC_INVALID: root::ppc_bc = 0;
    pub const ppc_bc_PPC_BC_LT: root::ppc_bc = 12;
    pub const ppc_bc_PPC_BC_LE: root::ppc_bc = 36;
    pub const ppc_bc_PPC_BC_EQ: root::ppc_bc = 76;
    pub const ppc_bc_PPC_BC_GE: root::ppc_bc = 4;
    pub const ppc_bc_PPC_BC_GT: root::ppc_bc = 44;
    pub const ppc_bc_PPC_BC_NE: root::ppc_bc = 68;
    pub const ppc_bc_PPC_BC_UN: root::ppc_bc = 108;
    pub const ppc_bc_PPC_BC_NU: root::ppc_bc = 100;
    #[doc = "< summary overflow"]
    pub const ppc_bc_PPC_BC_SO: root::ppc_bc = 140;
    #[doc = "< not summary overflow"]
    pub const ppc_bc_PPC_BC_NS: root::ppc_bc = 132;
    #[doc = " PPC branch codes for some branch instructions"]
    pub type ppc_bc = cty::c_int;
    #[doc = "< no hint"]
    pub const ppc_bh_PPC_BH_INVALID: root::ppc_bh = 0;
    #[doc = "< PLUS hint"]
    pub const ppc_bh_PPC_BH_PLUS: root::ppc_bh = 1;
    #[doc = "< MINUS hint"]
    pub const ppc_bh_PPC_BH_MINUS: root::ppc_bh = 2;
    #[doc = " PPC branch hint for some branch instructions"]
    pub type ppc_bh = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const ppc_op_type_PPC_OP_INVALID: root::ppc_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const ppc_op_type_PPC_OP_REG: root::ppc_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const ppc_op_type_PPC_OP_IMM: root::ppc_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const ppc_op_type_PPC_OP_MEM: root::ppc_op_type = 3;
    #[doc = "< Condition Register field"]
    pub const ppc_op_type_PPC_OP_CRX: root::ppc_op_type = 64;
    #[doc = " Operand type for instruction's operands"]
    pub type ppc_op_type = cty::c_int;
    pub const ppc_reg_PPC_REG_INVALID: root::ppc_reg = 0;
    pub const ppc_reg_PPC_REG_CARRY: root::ppc_reg = 2;
    pub const ppc_reg_PPC_REG_CTR: root::ppc_reg = 3;
    pub const ppc_reg_PPC_REG_LR: root::ppc_reg = 5;
    pub const ppc_reg_PPC_REG_RM: root::ppc_reg = 6;
    pub const ppc_reg_PPC_REG_VRSAVE: root::ppc_reg = 8;
    pub const ppc_reg_PPC_REG_XER: root::ppc_reg = 9;
    pub const ppc_reg_PPC_REG_ZERO: root::ppc_reg = 10;
    pub const ppc_reg_PPC_REG_CR0: root::ppc_reg = 12;
    pub const ppc_reg_PPC_REG_CR1: root::ppc_reg = 13;
    pub const ppc_reg_PPC_REG_CR2: root::ppc_reg = 14;
    pub const ppc_reg_PPC_REG_CR3: root::ppc_reg = 15;
    pub const ppc_reg_PPC_REG_CR4: root::ppc_reg = 16;
    pub const ppc_reg_PPC_REG_CR5: root::ppc_reg = 17;
    pub const ppc_reg_PPC_REG_CR6: root::ppc_reg = 18;
    pub const ppc_reg_PPC_REG_CR7: root::ppc_reg = 19;
    pub const ppc_reg_PPC_REG_CTR8: root::ppc_reg = 20;
    pub const ppc_reg_PPC_REG_F0: root::ppc_reg = 21;
    pub const ppc_reg_PPC_REG_F1: root::ppc_reg = 22;
    pub const ppc_reg_PPC_REG_F2: root::ppc_reg = 23;
    pub const ppc_reg_PPC_REG_F3: root::ppc_reg = 24;
    pub const ppc_reg_PPC_REG_F4: root::ppc_reg = 25;
    pub const ppc_reg_PPC_REG_F5: root::ppc_reg = 26;
    pub const ppc_reg_PPC_REG_F6: root::ppc_reg = 27;
    pub const ppc_reg_PPC_REG_F7: root::ppc_reg = 28;
    pub const ppc_reg_PPC_REG_F8: root::ppc_reg = 29;
    pub const ppc_reg_PPC_REG_F9: root::ppc_reg = 30;
    pub const ppc_reg_PPC_REG_F10: root::ppc_reg = 31;
    pub const ppc_reg_PPC_REG_F11: root::ppc_reg = 32;
    pub const ppc_reg_PPC_REG_F12: root::ppc_reg = 33;
    pub const ppc_reg_PPC_REG_F13: root::ppc_reg = 34;
    pub const ppc_reg_PPC_REG_F14: root::ppc_reg = 35;
    pub const ppc_reg_PPC_REG_F15: root::ppc_reg = 36;
    pub const ppc_reg_PPC_REG_F16: root::ppc_reg = 37;
    pub const ppc_reg_PPC_REG_F17: root::ppc_reg = 38;
    pub const ppc_reg_PPC_REG_F18: root::ppc_reg = 39;
    pub const ppc_reg_PPC_REG_F19: root::ppc_reg = 40;
    pub const ppc_reg_PPC_REG_F20: root::ppc_reg = 41;
    pub const ppc_reg_PPC_REG_F21: root::ppc_reg = 42;
    pub const ppc_reg_PPC_REG_F22: root::ppc_reg = 43;
    pub const ppc_reg_PPC_REG_F23: root::ppc_reg = 44;
    pub const ppc_reg_PPC_REG_F24: root::ppc_reg = 45;
    pub const ppc_reg_PPC_REG_F25: root::ppc_reg = 46;
    pub const ppc_reg_PPC_REG_F26: root::ppc_reg = 47;
    pub const ppc_reg_PPC_REG_F27: root::ppc_reg = 48;
    pub const ppc_reg_PPC_REG_F28: root::ppc_reg = 49;
    pub const ppc_reg_PPC_REG_F29: root::ppc_reg = 50;
    pub const ppc_reg_PPC_REG_F30: root::ppc_reg = 51;
    pub const ppc_reg_PPC_REG_F31: root::ppc_reg = 52;
    pub const ppc_reg_PPC_REG_LR8: root::ppc_reg = 54;
    pub const ppc_reg_PPC_REG_Q0: root::ppc_reg = 55;
    pub const ppc_reg_PPC_REG_Q1: root::ppc_reg = 56;
    pub const ppc_reg_PPC_REG_Q2: root::ppc_reg = 57;
    pub const ppc_reg_PPC_REG_Q3: root::ppc_reg = 58;
    pub const ppc_reg_PPC_REG_Q4: root::ppc_reg = 59;
    pub const ppc_reg_PPC_REG_Q5: root::ppc_reg = 60;
    pub const ppc_reg_PPC_REG_Q6: root::ppc_reg = 61;
    pub const ppc_reg_PPC_REG_Q7: root::ppc_reg = 62;
    pub const ppc_reg_PPC_REG_Q8: root::ppc_reg = 63;
    pub const ppc_reg_PPC_REG_Q9: root::ppc_reg = 64;
    pub const ppc_reg_PPC_REG_Q10: root::ppc_reg = 65;
    pub const ppc_reg_PPC_REG_Q11: root::ppc_reg = 66;
    pub const ppc_reg_PPC_REG_Q12: root::ppc_reg = 67;
    pub const ppc_reg_PPC_REG_Q13: root::ppc_reg = 68;
    pub const ppc_reg_PPC_REG_Q14: root::ppc_reg = 69;
    pub const ppc_reg_PPC_REG_Q15: root::ppc_reg = 70;
    pub const ppc_reg_PPC_REG_Q16: root::ppc_reg = 71;
    pub const ppc_reg_PPC_REG_Q17: root::ppc_reg = 72;
    pub const ppc_reg_PPC_REG_Q18: root::ppc_reg = 73;
    pub const ppc_reg_PPC_REG_Q19: root::ppc_reg = 74;
    pub const ppc_reg_PPC_REG_Q20: root::ppc_reg = 75;
    pub const ppc_reg_PPC_REG_Q21: root::ppc_reg = 76;
    pub const ppc_reg_PPC_REG_Q22: root::ppc_reg = 77;
    pub const ppc_reg_PPC_REG_Q23: root::ppc_reg = 78;
    pub const ppc_reg_PPC_REG_Q24: root::ppc_reg = 79;
    pub const ppc_reg_PPC_REG_Q25: root::ppc_reg = 80;
    pub const ppc_reg_PPC_REG_Q26: root::ppc_reg = 81;
    pub const ppc_reg_PPC_REG_Q27: root::ppc_reg = 82;
    pub const ppc_reg_PPC_REG_Q28: root::ppc_reg = 83;
    pub const ppc_reg_PPC_REG_Q29: root::ppc_reg = 84;
    pub const ppc_reg_PPC_REG_Q30: root::ppc_reg = 85;
    pub const ppc_reg_PPC_REG_Q31: root::ppc_reg = 86;
    pub const ppc_reg_PPC_REG_R0: root::ppc_reg = 87;
    pub const ppc_reg_PPC_REG_R1: root::ppc_reg = 88;
    pub const ppc_reg_PPC_REG_R2: root::ppc_reg = 89;
    pub const ppc_reg_PPC_REG_R3: root::ppc_reg = 90;
    pub const ppc_reg_PPC_REG_R4: root::ppc_reg = 91;
    pub const ppc_reg_PPC_REG_R5: root::ppc_reg = 92;
    pub const ppc_reg_PPC_REG_R6: root::ppc_reg = 93;
    pub const ppc_reg_PPC_REG_R7: root::ppc_reg = 94;
    pub const ppc_reg_PPC_REG_R8: root::ppc_reg = 95;
    pub const ppc_reg_PPC_REG_R9: root::ppc_reg = 96;
    pub const ppc_reg_PPC_REG_R10: root::ppc_reg = 97;
    pub const ppc_reg_PPC_REG_R11: root::ppc_reg = 98;
    pub const ppc_reg_PPC_REG_R12: root::ppc_reg = 99;
    pub const ppc_reg_PPC_REG_R13: root::ppc_reg = 100;
    pub const ppc_reg_PPC_REG_R14: root::ppc_reg = 101;
    pub const ppc_reg_PPC_REG_R15: root::ppc_reg = 102;
    pub const ppc_reg_PPC_REG_R16: root::ppc_reg = 103;
    pub const ppc_reg_PPC_REG_R17: root::ppc_reg = 104;
    pub const ppc_reg_PPC_REG_R18: root::ppc_reg = 105;
    pub const ppc_reg_PPC_REG_R19: root::ppc_reg = 106;
    pub const ppc_reg_PPC_REG_R20: root::ppc_reg = 107;
    pub const ppc_reg_PPC_REG_R21: root::ppc_reg = 108;
    pub const ppc_reg_PPC_REG_R22: root::ppc_reg = 109;
    pub const ppc_reg_PPC_REG_R23: root::ppc_reg = 110;
    pub const ppc_reg_PPC_REG_R24: root::ppc_reg = 111;
    pub const ppc_reg_PPC_REG_R25: root::ppc_reg = 112;
    pub const ppc_reg_PPC_REG_R26: root::ppc_reg = 113;
    pub const ppc_reg_PPC_REG_R27: root::ppc_reg = 114;
    pub const ppc_reg_PPC_REG_R28: root::ppc_reg = 115;
    pub const ppc_reg_PPC_REG_R29: root::ppc_reg = 116;
    pub const ppc_reg_PPC_REG_R30: root::ppc_reg = 117;
    pub const ppc_reg_PPC_REG_R31: root::ppc_reg = 118;
    pub const ppc_reg_PPC_REG_V0: root::ppc_reg = 151;
    pub const ppc_reg_PPC_REG_V1: root::ppc_reg = 152;
    pub const ppc_reg_PPC_REG_V2: root::ppc_reg = 153;
    pub const ppc_reg_PPC_REG_V3: root::ppc_reg = 154;
    pub const ppc_reg_PPC_REG_V4: root::ppc_reg = 155;
    pub const ppc_reg_PPC_REG_V5: root::ppc_reg = 156;
    pub const ppc_reg_PPC_REG_V6: root::ppc_reg = 157;
    pub const ppc_reg_PPC_REG_V7: root::ppc_reg = 158;
    pub const ppc_reg_PPC_REG_V8: root::ppc_reg = 159;
    pub const ppc_reg_PPC_REG_V9: root::ppc_reg = 160;
    pub const ppc_reg_PPC_REG_V10: root::ppc_reg = 161;
    pub const ppc_reg_PPC_REG_V11: root::ppc_reg = 162;
    pub const ppc_reg_PPC_REG_V12: root::ppc_reg = 163;
    pub const ppc_reg_PPC_REG_V13: root::ppc_reg = 164;
    pub const ppc_reg_PPC_REG_V14: root::ppc_reg = 165;
    pub const ppc_reg_PPC_REG_V15: root::ppc_reg = 166;
    pub const ppc_reg_PPC_REG_V16: root::ppc_reg = 167;
    pub const ppc_reg_PPC_REG_V17: root::ppc_reg = 168;
    pub const ppc_reg_PPC_REG_V18: root::ppc_reg = 169;
    pub const ppc_reg_PPC_REG_V19: root::ppc_reg = 170;
    pub const ppc_reg_PPC_REG_V20: root::ppc_reg = 171;
    pub const ppc_reg_PPC_REG_V21: root::ppc_reg = 172;
    pub const ppc_reg_PPC_REG_V22: root::ppc_reg = 173;
    pub const ppc_reg_PPC_REG_V23: root::ppc_reg = 174;
    pub const ppc_reg_PPC_REG_V24: root::ppc_reg = 175;
    pub const ppc_reg_PPC_REG_V25: root::ppc_reg = 176;
    pub const ppc_reg_PPC_REG_V26: root::ppc_reg = 177;
    pub const ppc_reg_PPC_REG_V27: root::ppc_reg = 178;
    pub const ppc_reg_PPC_REG_V28: root::ppc_reg = 179;
    pub const ppc_reg_PPC_REG_V29: root::ppc_reg = 180;
    pub const ppc_reg_PPC_REG_V30: root::ppc_reg = 181;
    pub const ppc_reg_PPC_REG_V31: root::ppc_reg = 182;
    pub const ppc_reg_PPC_REG_VS0: root::ppc_reg = 215;
    pub const ppc_reg_PPC_REG_VS1: root::ppc_reg = 216;
    pub const ppc_reg_PPC_REG_VS2: root::ppc_reg = 217;
    pub const ppc_reg_PPC_REG_VS3: root::ppc_reg = 218;
    pub const ppc_reg_PPC_REG_VS4: root::ppc_reg = 219;
    pub const ppc_reg_PPC_REG_VS5: root::ppc_reg = 220;
    pub const ppc_reg_PPC_REG_VS6: root::ppc_reg = 221;
    pub const ppc_reg_PPC_REG_VS7: root::ppc_reg = 222;
    pub const ppc_reg_PPC_REG_VS8: root::ppc_reg = 223;
    pub const ppc_reg_PPC_REG_VS9: root::ppc_reg = 224;
    pub const ppc_reg_PPC_REG_VS10: root::ppc_reg = 225;
    pub const ppc_reg_PPC_REG_VS11: root::ppc_reg = 226;
    pub const ppc_reg_PPC_REG_VS12: root::ppc_reg = 227;
    pub const ppc_reg_PPC_REG_VS13: root::ppc_reg = 228;
    pub const ppc_reg_PPC_REG_VS14: root::ppc_reg = 229;
    pub const ppc_reg_PPC_REG_VS15: root::ppc_reg = 230;
    pub const ppc_reg_PPC_REG_VS16: root::ppc_reg = 231;
    pub const ppc_reg_PPC_REG_VS17: root::ppc_reg = 232;
    pub const ppc_reg_PPC_REG_VS18: root::ppc_reg = 233;
    pub const ppc_reg_PPC_REG_VS19: root::ppc_reg = 234;
    pub const ppc_reg_PPC_REG_VS20: root::ppc_reg = 235;
    pub const ppc_reg_PPC_REG_VS21: root::ppc_reg = 236;
    pub const ppc_reg_PPC_REG_VS22: root::ppc_reg = 237;
    pub const ppc_reg_PPC_REG_VS23: root::ppc_reg = 238;
    pub const ppc_reg_PPC_REG_VS24: root::ppc_reg = 239;
    pub const ppc_reg_PPC_REG_VS25: root::ppc_reg = 240;
    pub const ppc_reg_PPC_REG_VS26: root::ppc_reg = 241;
    pub const ppc_reg_PPC_REG_VS27: root::ppc_reg = 242;
    pub const ppc_reg_PPC_REG_VS28: root::ppc_reg = 243;
    pub const ppc_reg_PPC_REG_VS29: root::ppc_reg = 244;
    pub const ppc_reg_PPC_REG_VS30: root::ppc_reg = 245;
    pub const ppc_reg_PPC_REG_VS31: root::ppc_reg = 246;
    pub const ppc_reg_PPC_REG_VS32: root::ppc_reg = 247;
    pub const ppc_reg_PPC_REG_VS33: root::ppc_reg = 248;
    pub const ppc_reg_PPC_REG_VS34: root::ppc_reg = 249;
    pub const ppc_reg_PPC_REG_VS35: root::ppc_reg = 250;
    pub const ppc_reg_PPC_REG_VS36: root::ppc_reg = 251;
    pub const ppc_reg_PPC_REG_VS37: root::ppc_reg = 252;
    pub const ppc_reg_PPC_REG_VS38: root::ppc_reg = 253;
    pub const ppc_reg_PPC_REG_VS39: root::ppc_reg = 254;
    pub const ppc_reg_PPC_REG_VS40: root::ppc_reg = 255;
    pub const ppc_reg_PPC_REG_VS41: root::ppc_reg = 256;
    pub const ppc_reg_PPC_REG_VS42: root::ppc_reg = 257;
    pub const ppc_reg_PPC_REG_VS43: root::ppc_reg = 258;
    pub const ppc_reg_PPC_REG_VS44: root::ppc_reg = 259;
    pub const ppc_reg_PPC_REG_VS45: root::ppc_reg = 260;
    pub const ppc_reg_PPC_REG_VS46: root::ppc_reg = 261;
    pub const ppc_reg_PPC_REG_VS47: root::ppc_reg = 262;
    pub const ppc_reg_PPC_REG_VS48: root::ppc_reg = 263;
    pub const ppc_reg_PPC_REG_VS49: root::ppc_reg = 264;
    pub const ppc_reg_PPC_REG_VS50: root::ppc_reg = 265;
    pub const ppc_reg_PPC_REG_VS51: root::ppc_reg = 266;
    pub const ppc_reg_PPC_REG_VS52: root::ppc_reg = 267;
    pub const ppc_reg_PPC_REG_VS53: root::ppc_reg = 268;
    pub const ppc_reg_PPC_REG_VS54: root::ppc_reg = 269;
    pub const ppc_reg_PPC_REG_VS55: root::ppc_reg = 270;
    pub const ppc_reg_PPC_REG_VS56: root::ppc_reg = 271;
    pub const ppc_reg_PPC_REG_VS57: root::ppc_reg = 272;
    pub const ppc_reg_PPC_REG_VS58: root::ppc_reg = 273;
    pub const ppc_reg_PPC_REG_VS59: root::ppc_reg = 274;
    pub const ppc_reg_PPC_REG_VS60: root::ppc_reg = 275;
    pub const ppc_reg_PPC_REG_VS61: root::ppc_reg = 276;
    pub const ppc_reg_PPC_REG_VS62: root::ppc_reg = 277;
    pub const ppc_reg_PPC_REG_VS63: root::ppc_reg = 278;
    pub const ppc_reg_PPC_REG_CR0EQ: root::ppc_reg = 312;
    pub const ppc_reg_PPC_REG_CR1EQ: root::ppc_reg = 313;
    pub const ppc_reg_PPC_REG_CR2EQ: root::ppc_reg = 314;
    pub const ppc_reg_PPC_REG_CR3EQ: root::ppc_reg = 315;
    pub const ppc_reg_PPC_REG_CR4EQ: root::ppc_reg = 316;
    pub const ppc_reg_PPC_REG_CR5EQ: root::ppc_reg = 317;
    pub const ppc_reg_PPC_REG_CR6EQ: root::ppc_reg = 318;
    pub const ppc_reg_PPC_REG_CR7EQ: root::ppc_reg = 319;
    pub const ppc_reg_PPC_REG_CR0GT: root::ppc_reg = 320;
    pub const ppc_reg_PPC_REG_CR1GT: root::ppc_reg = 321;
    pub const ppc_reg_PPC_REG_CR2GT: root::ppc_reg = 322;
    pub const ppc_reg_PPC_REG_CR3GT: root::ppc_reg = 323;
    pub const ppc_reg_PPC_REG_CR4GT: root::ppc_reg = 324;
    pub const ppc_reg_PPC_REG_CR5GT: root::ppc_reg = 325;
    pub const ppc_reg_PPC_REG_CR6GT: root::ppc_reg = 326;
    pub const ppc_reg_PPC_REG_CR7GT: root::ppc_reg = 327;
    pub const ppc_reg_PPC_REG_CR0LT: root::ppc_reg = 328;
    pub const ppc_reg_PPC_REG_CR1LT: root::ppc_reg = 329;
    pub const ppc_reg_PPC_REG_CR2LT: root::ppc_reg = 330;
    pub const ppc_reg_PPC_REG_CR3LT: root::ppc_reg = 331;
    pub const ppc_reg_PPC_REG_CR4LT: root::ppc_reg = 332;
    pub const ppc_reg_PPC_REG_CR5LT: root::ppc_reg = 333;
    pub const ppc_reg_PPC_REG_CR6LT: root::ppc_reg = 334;
    pub const ppc_reg_PPC_REG_CR7LT: root::ppc_reg = 335;
    pub const ppc_reg_PPC_REG_CR0UN: root::ppc_reg = 336;
    pub const ppc_reg_PPC_REG_CR1UN: root::ppc_reg = 337;
    pub const ppc_reg_PPC_REG_CR2UN: root::ppc_reg = 338;
    pub const ppc_reg_PPC_REG_CR3UN: root::ppc_reg = 339;
    pub const ppc_reg_PPC_REG_CR4UN: root::ppc_reg = 340;
    pub const ppc_reg_PPC_REG_CR5UN: root::ppc_reg = 341;
    pub const ppc_reg_PPC_REG_CR6UN: root::ppc_reg = 342;
    pub const ppc_reg_PPC_REG_CR7UN: root::ppc_reg = 343;
    pub const ppc_reg_PPC_REG_ENDING: root::ppc_reg = 344;
    #[doc = " PPC registers"]
    pub type ppc_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with PPC_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ppc_op_mem {
        #[doc = "< base register"]
        pub base: root::ppc_reg,
        #[doc = "< displacement/offset value"]
        pub disp: i32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ppc_op_crx {
        pub scale: cty::c_uint,
        pub reg: root::ppc_reg,
        pub cond: root::ppc_bc,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_ppc_op {
        #[doc = "< operand type"]
        pub type_: root::ppc_op_type,
        pub __bindgen_anon_1: root::cs_ppc_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_ppc_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: root::ppc_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i64,
        #[doc = "< base/disp value for MEM operand"]
        pub mem: root::ppc_op_mem,
        #[doc = "< operand with condition register"]
        pub crx: root::ppc_op_crx,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_ppc {
        #[doc = " branch code for branch instructions"]
        pub bc: root::ppc_bc,
        #[doc = " branch hint for branch instructions"]
        pub bh: root::ppc_bh,
        #[doc = " if update_cr0 = True, then this 'dot' insn updates CR0"]
        pub update_cr0: bool,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_ppc_op; 8usize],
    }
    #[doc = "< invalid CC (default)"]
    pub const sparc_cc_SPARC_CC_INVALID: root::sparc_cc = 0;
    #[doc = "< Always"]
    pub const sparc_cc_SPARC_CC_ICC_A: root::sparc_cc = 264;
    #[doc = "< Never"]
    pub const sparc_cc_SPARC_CC_ICC_N: root::sparc_cc = 256;
    #[doc = "< Not Equal"]
    pub const sparc_cc_SPARC_CC_ICC_NE: root::sparc_cc = 265;
    #[doc = "< Equal"]
    pub const sparc_cc_SPARC_CC_ICC_E: root::sparc_cc = 257;
    #[doc = "< Greater"]
    pub const sparc_cc_SPARC_CC_ICC_G: root::sparc_cc = 266;
    #[doc = "< Less or Equal"]
    pub const sparc_cc_SPARC_CC_ICC_LE: root::sparc_cc = 258;
    #[doc = "< Greater or Equal"]
    pub const sparc_cc_SPARC_CC_ICC_GE: root::sparc_cc = 267;
    #[doc = "< Less"]
    pub const sparc_cc_SPARC_CC_ICC_L: root::sparc_cc = 259;
    #[doc = "< Greater Unsigned"]
    pub const sparc_cc_SPARC_CC_ICC_GU: root::sparc_cc = 268;
    #[doc = "< Less or Equal Unsigned"]
    pub const sparc_cc_SPARC_CC_ICC_LEU: root::sparc_cc = 260;
    #[doc = "< Carry Clear/Great or Equal Unsigned"]
    pub const sparc_cc_SPARC_CC_ICC_CC: root::sparc_cc = 269;
    #[doc = "< Carry Set/Less Unsigned"]
    pub const sparc_cc_SPARC_CC_ICC_CS: root::sparc_cc = 261;
    #[doc = "< Positive"]
    pub const sparc_cc_SPARC_CC_ICC_POS: root::sparc_cc = 270;
    #[doc = "< Negative"]
    pub const sparc_cc_SPARC_CC_ICC_NEG: root::sparc_cc = 262;
    #[doc = "< Overflow Clear"]
    pub const sparc_cc_SPARC_CC_ICC_VC: root::sparc_cc = 271;
    #[doc = "< Overflow Set"]
    pub const sparc_cc_SPARC_CC_ICC_VS: root::sparc_cc = 263;
    #[doc = "< Always"]
    pub const sparc_cc_SPARC_CC_FCC_A: root::sparc_cc = 280;
    #[doc = "< Never"]
    pub const sparc_cc_SPARC_CC_FCC_N: root::sparc_cc = 272;
    #[doc = "< Unordered"]
    pub const sparc_cc_SPARC_CC_FCC_U: root::sparc_cc = 279;
    #[doc = "< Greater"]
    pub const sparc_cc_SPARC_CC_FCC_G: root::sparc_cc = 278;
    #[doc = "< Unordered or Greater"]
    pub const sparc_cc_SPARC_CC_FCC_UG: root::sparc_cc = 277;
    #[doc = "< Less"]
    pub const sparc_cc_SPARC_CC_FCC_L: root::sparc_cc = 276;
    #[doc = "< Unordered or Less"]
    pub const sparc_cc_SPARC_CC_FCC_UL: root::sparc_cc = 275;
    #[doc = "< Less or Greater"]
    pub const sparc_cc_SPARC_CC_FCC_LG: root::sparc_cc = 274;
    #[doc = "< Not Equal"]
    pub const sparc_cc_SPARC_CC_FCC_NE: root::sparc_cc = 273;
    #[doc = "< Equal"]
    pub const sparc_cc_SPARC_CC_FCC_E: root::sparc_cc = 281;
    #[doc = "< Unordered or Equal"]
    pub const sparc_cc_SPARC_CC_FCC_UE: root::sparc_cc = 282;
    #[doc = "< Greater or Equal"]
    pub const sparc_cc_SPARC_CC_FCC_GE: root::sparc_cc = 283;
    #[doc = "< Unordered or Greater or Equal"]
    pub const sparc_cc_SPARC_CC_FCC_UGE: root::sparc_cc = 284;
    #[doc = "< Less or Equal"]
    pub const sparc_cc_SPARC_CC_FCC_LE: root::sparc_cc = 285;
    #[doc = "< Unordered or Less or Equal"]
    pub const sparc_cc_SPARC_CC_FCC_ULE: root::sparc_cc = 286;
    #[doc = "< Ordered"]
    pub const sparc_cc_SPARC_CC_FCC_O: root::sparc_cc = 287;
    #[doc = " Enums corresponding to Sparc condition codes, both icc's and fcc's."]
    pub type sparc_cc = cty::c_int;
    #[doc = "< no hint"]
    pub const sparc_hint_SPARC_HINT_INVALID: root::sparc_hint = 0;
    #[doc = "< annul delay slot instruction"]
    pub const sparc_hint_SPARC_HINT_A: root::sparc_hint = 1;
    #[doc = "< branch taken"]
    pub const sparc_hint_SPARC_HINT_PT: root::sparc_hint = 2;
    #[doc = "< branch NOT taken"]
    pub const sparc_hint_SPARC_HINT_PN: root::sparc_hint = 4;
    #[doc = " Branch hint"]
    pub type sparc_hint = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const sparc_op_type_SPARC_OP_INVALID: root::sparc_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const sparc_op_type_SPARC_OP_REG: root::sparc_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const sparc_op_type_SPARC_OP_IMM: root::sparc_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const sparc_op_type_SPARC_OP_MEM: root::sparc_op_type = 3;
    #[doc = " Operand type for instruction's operands"]
    pub type sparc_op_type = cty::c_int;
    pub const sparc_reg_SPARC_REG_INVALID: root::sparc_reg = 0;
    pub const sparc_reg_SPARC_REG_F0: root::sparc_reg = 1;
    pub const sparc_reg_SPARC_REG_F1: root::sparc_reg = 2;
    pub const sparc_reg_SPARC_REG_F2: root::sparc_reg = 3;
    pub const sparc_reg_SPARC_REG_F3: root::sparc_reg = 4;
    pub const sparc_reg_SPARC_REG_F4: root::sparc_reg = 5;
    pub const sparc_reg_SPARC_REG_F5: root::sparc_reg = 6;
    pub const sparc_reg_SPARC_REG_F6: root::sparc_reg = 7;
    pub const sparc_reg_SPARC_REG_F7: root::sparc_reg = 8;
    pub const sparc_reg_SPARC_REG_F8: root::sparc_reg = 9;
    pub const sparc_reg_SPARC_REG_F9: root::sparc_reg = 10;
    pub const sparc_reg_SPARC_REG_F10: root::sparc_reg = 11;
    pub const sparc_reg_SPARC_REG_F11: root::sparc_reg = 12;
    pub const sparc_reg_SPARC_REG_F12: root::sparc_reg = 13;
    pub const sparc_reg_SPARC_REG_F13: root::sparc_reg = 14;
    pub const sparc_reg_SPARC_REG_F14: root::sparc_reg = 15;
    pub const sparc_reg_SPARC_REG_F15: root::sparc_reg = 16;
    pub const sparc_reg_SPARC_REG_F16: root::sparc_reg = 17;
    pub const sparc_reg_SPARC_REG_F17: root::sparc_reg = 18;
    pub const sparc_reg_SPARC_REG_F18: root::sparc_reg = 19;
    pub const sparc_reg_SPARC_REG_F19: root::sparc_reg = 20;
    pub const sparc_reg_SPARC_REG_F20: root::sparc_reg = 21;
    pub const sparc_reg_SPARC_REG_F21: root::sparc_reg = 22;
    pub const sparc_reg_SPARC_REG_F22: root::sparc_reg = 23;
    pub const sparc_reg_SPARC_REG_F23: root::sparc_reg = 24;
    pub const sparc_reg_SPARC_REG_F24: root::sparc_reg = 25;
    pub const sparc_reg_SPARC_REG_F25: root::sparc_reg = 26;
    pub const sparc_reg_SPARC_REG_F26: root::sparc_reg = 27;
    pub const sparc_reg_SPARC_REG_F27: root::sparc_reg = 28;
    pub const sparc_reg_SPARC_REG_F28: root::sparc_reg = 29;
    pub const sparc_reg_SPARC_REG_F29: root::sparc_reg = 30;
    pub const sparc_reg_SPARC_REG_F30: root::sparc_reg = 31;
    pub const sparc_reg_SPARC_REG_F31: root::sparc_reg = 32;
    pub const sparc_reg_SPARC_REG_F32: root::sparc_reg = 33;
    pub const sparc_reg_SPARC_REG_F34: root::sparc_reg = 34;
    pub const sparc_reg_SPARC_REG_F36: root::sparc_reg = 35;
    pub const sparc_reg_SPARC_REG_F38: root::sparc_reg = 36;
    pub const sparc_reg_SPARC_REG_F40: root::sparc_reg = 37;
    pub const sparc_reg_SPARC_REG_F42: root::sparc_reg = 38;
    pub const sparc_reg_SPARC_REG_F44: root::sparc_reg = 39;
    pub const sparc_reg_SPARC_REG_F46: root::sparc_reg = 40;
    pub const sparc_reg_SPARC_REG_F48: root::sparc_reg = 41;
    pub const sparc_reg_SPARC_REG_F50: root::sparc_reg = 42;
    pub const sparc_reg_SPARC_REG_F52: root::sparc_reg = 43;
    pub const sparc_reg_SPARC_REG_F54: root::sparc_reg = 44;
    pub const sparc_reg_SPARC_REG_F56: root::sparc_reg = 45;
    pub const sparc_reg_SPARC_REG_F58: root::sparc_reg = 46;
    pub const sparc_reg_SPARC_REG_F60: root::sparc_reg = 47;
    pub const sparc_reg_SPARC_REG_F62: root::sparc_reg = 48;
    pub const sparc_reg_SPARC_REG_FCC0: root::sparc_reg = 49;
    pub const sparc_reg_SPARC_REG_FCC1: root::sparc_reg = 50;
    pub const sparc_reg_SPARC_REG_FCC2: root::sparc_reg = 51;
    pub const sparc_reg_SPARC_REG_FCC3: root::sparc_reg = 52;
    pub const sparc_reg_SPARC_REG_FP: root::sparc_reg = 53;
    pub const sparc_reg_SPARC_REG_G0: root::sparc_reg = 54;
    pub const sparc_reg_SPARC_REG_G1: root::sparc_reg = 55;
    pub const sparc_reg_SPARC_REG_G2: root::sparc_reg = 56;
    pub const sparc_reg_SPARC_REG_G3: root::sparc_reg = 57;
    pub const sparc_reg_SPARC_REG_G4: root::sparc_reg = 58;
    pub const sparc_reg_SPARC_REG_G5: root::sparc_reg = 59;
    pub const sparc_reg_SPARC_REG_G6: root::sparc_reg = 60;
    pub const sparc_reg_SPARC_REG_G7: root::sparc_reg = 61;
    pub const sparc_reg_SPARC_REG_I0: root::sparc_reg = 62;
    pub const sparc_reg_SPARC_REG_I1: root::sparc_reg = 63;
    pub const sparc_reg_SPARC_REG_I2: root::sparc_reg = 64;
    pub const sparc_reg_SPARC_REG_I3: root::sparc_reg = 65;
    pub const sparc_reg_SPARC_REG_I4: root::sparc_reg = 66;
    pub const sparc_reg_SPARC_REG_I5: root::sparc_reg = 67;
    pub const sparc_reg_SPARC_REG_I7: root::sparc_reg = 68;
    pub const sparc_reg_SPARC_REG_ICC: root::sparc_reg = 69;
    pub const sparc_reg_SPARC_REG_L0: root::sparc_reg = 70;
    pub const sparc_reg_SPARC_REG_L1: root::sparc_reg = 71;
    pub const sparc_reg_SPARC_REG_L2: root::sparc_reg = 72;
    pub const sparc_reg_SPARC_REG_L3: root::sparc_reg = 73;
    pub const sparc_reg_SPARC_REG_L4: root::sparc_reg = 74;
    pub const sparc_reg_SPARC_REG_L5: root::sparc_reg = 75;
    pub const sparc_reg_SPARC_REG_L6: root::sparc_reg = 76;
    pub const sparc_reg_SPARC_REG_L7: root::sparc_reg = 77;
    pub const sparc_reg_SPARC_REG_O0: root::sparc_reg = 78;
    pub const sparc_reg_SPARC_REG_O1: root::sparc_reg = 79;
    pub const sparc_reg_SPARC_REG_O2: root::sparc_reg = 80;
    pub const sparc_reg_SPARC_REG_O3: root::sparc_reg = 81;
    pub const sparc_reg_SPARC_REG_O4: root::sparc_reg = 82;
    pub const sparc_reg_SPARC_REG_O5: root::sparc_reg = 83;
    pub const sparc_reg_SPARC_REG_O7: root::sparc_reg = 84;
    pub const sparc_reg_SPARC_REG_SP: root::sparc_reg = 85;
    pub const sparc_reg_SPARC_REG_Y: root::sparc_reg = 86;
    pub const sparc_reg_SPARC_REG_XCC: root::sparc_reg = 87;
    pub const sparc_reg_SPARC_REG_ENDING: root::sparc_reg = 88;
    pub const sparc_reg_SPARC_REG_O6: root::sparc_reg = 85;
    pub const sparc_reg_SPARC_REG_I6: root::sparc_reg = 53;
    #[doc = " SPARC registers"]
    pub type sparc_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with SPARC_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sparc_op_mem {
        #[doc = "< base register, can be safely interpreted as"]
        #[doc = "< a value of type `sparc_reg`, but it is only"]
        #[doc = "< one byte wide"]
        pub base: u8,
        #[doc = "< index register, same conditions apply here"]
        pub index: u8,
        #[doc = "< displacement/offset value"]
        pub disp: i32,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_sparc_op {
        #[doc = "< operand type"]
        pub type_: root::sparc_op_type,
        pub __bindgen_anon_1: root::cs_sparc_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_sparc_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: root::sparc_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i64,
        #[doc = "< base/disp value for MEM operand"]
        pub mem: root::sparc_op_mem,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_sparc {
        #[doc = "< code condition for this insn"]
        pub cc: root::sparc_cc,
        #[doc = "< branch hint: encoding as bitwise OR of sparc_hint."]
        pub hint: root::sparc_hint,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_sparc_op; 4usize],
    }
    #[doc = "< invalid CC (default)"]
    pub const sysz_cc_SYSZ_CC_INVALID: root::sysz_cc = 0;
    pub const sysz_cc_SYSZ_CC_O: root::sysz_cc = 1;
    pub const sysz_cc_SYSZ_CC_H: root::sysz_cc = 2;
    pub const sysz_cc_SYSZ_CC_NLE: root::sysz_cc = 3;
    pub const sysz_cc_SYSZ_CC_L: root::sysz_cc = 4;
    pub const sysz_cc_SYSZ_CC_NHE: root::sysz_cc = 5;
    pub const sysz_cc_SYSZ_CC_LH: root::sysz_cc = 6;
    pub const sysz_cc_SYSZ_CC_NE: root::sysz_cc = 7;
    pub const sysz_cc_SYSZ_CC_E: root::sysz_cc = 8;
    pub const sysz_cc_SYSZ_CC_NLH: root::sysz_cc = 9;
    pub const sysz_cc_SYSZ_CC_HE: root::sysz_cc = 10;
    pub const sysz_cc_SYSZ_CC_NL: root::sysz_cc = 11;
    pub const sysz_cc_SYSZ_CC_LE: root::sysz_cc = 12;
    pub const sysz_cc_SYSZ_CC_NH: root::sysz_cc = 13;
    pub const sysz_cc_SYSZ_CC_NO: root::sysz_cc = 14;
    #[doc = " Enums corresponding to SystemZ condition codes"]
    pub type sysz_cc = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const sysz_op_type_SYSZ_OP_INVALID: root::sysz_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const sysz_op_type_SYSZ_OP_REG: root::sysz_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const sysz_op_type_SYSZ_OP_IMM: root::sysz_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const sysz_op_type_SYSZ_OP_MEM: root::sysz_op_type = 3;
    #[doc = "< Access register operand."]
    pub const sysz_op_type_SYSZ_OP_ACREG: root::sysz_op_type = 64;
    #[doc = " Operand type for instruction's operands"]
    pub type sysz_op_type = cty::c_int;
    pub const sysz_reg_SYSZ_REG_INVALID: root::sysz_reg = 0;
    pub const sysz_reg_SYSZ_REG_0: root::sysz_reg = 1;
    pub const sysz_reg_SYSZ_REG_1: root::sysz_reg = 2;
    pub const sysz_reg_SYSZ_REG_2: root::sysz_reg = 3;
    pub const sysz_reg_SYSZ_REG_3: root::sysz_reg = 4;
    pub const sysz_reg_SYSZ_REG_4: root::sysz_reg = 5;
    pub const sysz_reg_SYSZ_REG_5: root::sysz_reg = 6;
    pub const sysz_reg_SYSZ_REG_6: root::sysz_reg = 7;
    pub const sysz_reg_SYSZ_REG_7: root::sysz_reg = 8;
    pub const sysz_reg_SYSZ_REG_8: root::sysz_reg = 9;
    pub const sysz_reg_SYSZ_REG_9: root::sysz_reg = 10;
    pub const sysz_reg_SYSZ_REG_10: root::sysz_reg = 11;
    pub const sysz_reg_SYSZ_REG_11: root::sysz_reg = 12;
    pub const sysz_reg_SYSZ_REG_12: root::sysz_reg = 13;
    pub const sysz_reg_SYSZ_REG_13: root::sysz_reg = 14;
    pub const sysz_reg_SYSZ_REG_14: root::sysz_reg = 15;
    pub const sysz_reg_SYSZ_REG_15: root::sysz_reg = 16;
    pub const sysz_reg_SYSZ_REG_CC: root::sysz_reg = 17;
    pub const sysz_reg_SYSZ_REG_F0: root::sysz_reg = 18;
    pub const sysz_reg_SYSZ_REG_F1: root::sysz_reg = 19;
    pub const sysz_reg_SYSZ_REG_F2: root::sysz_reg = 20;
    pub const sysz_reg_SYSZ_REG_F3: root::sysz_reg = 21;
    pub const sysz_reg_SYSZ_REG_F4: root::sysz_reg = 22;
    pub const sysz_reg_SYSZ_REG_F5: root::sysz_reg = 23;
    pub const sysz_reg_SYSZ_REG_F6: root::sysz_reg = 24;
    pub const sysz_reg_SYSZ_REG_F7: root::sysz_reg = 25;
    pub const sysz_reg_SYSZ_REG_F8: root::sysz_reg = 26;
    pub const sysz_reg_SYSZ_REG_F9: root::sysz_reg = 27;
    pub const sysz_reg_SYSZ_REG_F10: root::sysz_reg = 28;
    pub const sysz_reg_SYSZ_REG_F11: root::sysz_reg = 29;
    pub const sysz_reg_SYSZ_REG_F12: root::sysz_reg = 30;
    pub const sysz_reg_SYSZ_REG_F13: root::sysz_reg = 31;
    pub const sysz_reg_SYSZ_REG_F14: root::sysz_reg = 32;
    pub const sysz_reg_SYSZ_REG_F15: root::sysz_reg = 33;
    pub const sysz_reg_SYSZ_REG_R0L: root::sysz_reg = 34;
    pub const sysz_reg_SYSZ_REG_A0: root::sysz_reg = 35;
    pub const sysz_reg_SYSZ_REG_A1: root::sysz_reg = 36;
    pub const sysz_reg_SYSZ_REG_A2: root::sysz_reg = 37;
    pub const sysz_reg_SYSZ_REG_A3: root::sysz_reg = 38;
    pub const sysz_reg_SYSZ_REG_A4: root::sysz_reg = 39;
    pub const sysz_reg_SYSZ_REG_A5: root::sysz_reg = 40;
    pub const sysz_reg_SYSZ_REG_A6: root::sysz_reg = 41;
    pub const sysz_reg_SYSZ_REG_A7: root::sysz_reg = 42;
    pub const sysz_reg_SYSZ_REG_A8: root::sysz_reg = 43;
    pub const sysz_reg_SYSZ_REG_A9: root::sysz_reg = 44;
    pub const sysz_reg_SYSZ_REG_A10: root::sysz_reg = 45;
    pub const sysz_reg_SYSZ_REG_A11: root::sysz_reg = 46;
    pub const sysz_reg_SYSZ_REG_A12: root::sysz_reg = 47;
    pub const sysz_reg_SYSZ_REG_A13: root::sysz_reg = 48;
    pub const sysz_reg_SYSZ_REG_A14: root::sysz_reg = 49;
    pub const sysz_reg_SYSZ_REG_A15: root::sysz_reg = 50;
    pub const sysz_reg_SYSZ_REG_C0: root::sysz_reg = 51;
    pub const sysz_reg_SYSZ_REG_C1: root::sysz_reg = 52;
    pub const sysz_reg_SYSZ_REG_C2: root::sysz_reg = 53;
    pub const sysz_reg_SYSZ_REG_C3: root::sysz_reg = 54;
    pub const sysz_reg_SYSZ_REG_C4: root::sysz_reg = 55;
    pub const sysz_reg_SYSZ_REG_C5: root::sysz_reg = 56;
    pub const sysz_reg_SYSZ_REG_C6: root::sysz_reg = 57;
    pub const sysz_reg_SYSZ_REG_C7: root::sysz_reg = 58;
    pub const sysz_reg_SYSZ_REG_C8: root::sysz_reg = 59;
    pub const sysz_reg_SYSZ_REG_C9: root::sysz_reg = 60;
    pub const sysz_reg_SYSZ_REG_C10: root::sysz_reg = 61;
    pub const sysz_reg_SYSZ_REG_C11: root::sysz_reg = 62;
    pub const sysz_reg_SYSZ_REG_C12: root::sysz_reg = 63;
    pub const sysz_reg_SYSZ_REG_C13: root::sysz_reg = 64;
    pub const sysz_reg_SYSZ_REG_C14: root::sysz_reg = 65;
    pub const sysz_reg_SYSZ_REG_C15: root::sysz_reg = 66;
    pub const sysz_reg_SYSZ_REG_V0: root::sysz_reg = 67;
    pub const sysz_reg_SYSZ_REG_V1: root::sysz_reg = 68;
    pub const sysz_reg_SYSZ_REG_V2: root::sysz_reg = 69;
    pub const sysz_reg_SYSZ_REG_V3: root::sysz_reg = 70;
    pub const sysz_reg_SYSZ_REG_V4: root::sysz_reg = 71;
    pub const sysz_reg_SYSZ_REG_V5: root::sysz_reg = 72;
    pub const sysz_reg_SYSZ_REG_V6: root::sysz_reg = 73;
    pub const sysz_reg_SYSZ_REG_V7: root::sysz_reg = 74;
    pub const sysz_reg_SYSZ_REG_V8: root::sysz_reg = 75;
    pub const sysz_reg_SYSZ_REG_V9: root::sysz_reg = 76;
    pub const sysz_reg_SYSZ_REG_V10: root::sysz_reg = 77;
    pub const sysz_reg_SYSZ_REG_V11: root::sysz_reg = 78;
    pub const sysz_reg_SYSZ_REG_V12: root::sysz_reg = 79;
    pub const sysz_reg_SYSZ_REG_V13: root::sysz_reg = 80;
    pub const sysz_reg_SYSZ_REG_V14: root::sysz_reg = 81;
    pub const sysz_reg_SYSZ_REG_V15: root::sysz_reg = 82;
    pub const sysz_reg_SYSZ_REG_V16: root::sysz_reg = 83;
    pub const sysz_reg_SYSZ_REG_V17: root::sysz_reg = 84;
    pub const sysz_reg_SYSZ_REG_V18: root::sysz_reg = 85;
    pub const sysz_reg_SYSZ_REG_V19: root::sysz_reg = 86;
    pub const sysz_reg_SYSZ_REG_V20: root::sysz_reg = 87;
    pub const sysz_reg_SYSZ_REG_V21: root::sysz_reg = 88;
    pub const sysz_reg_SYSZ_REG_V22: root::sysz_reg = 89;
    pub const sysz_reg_SYSZ_REG_V23: root::sysz_reg = 90;
    pub const sysz_reg_SYSZ_REG_V24: root::sysz_reg = 91;
    pub const sysz_reg_SYSZ_REG_V25: root::sysz_reg = 92;
    pub const sysz_reg_SYSZ_REG_V26: root::sysz_reg = 93;
    pub const sysz_reg_SYSZ_REG_V27: root::sysz_reg = 94;
    pub const sysz_reg_SYSZ_REG_V28: root::sysz_reg = 95;
    pub const sysz_reg_SYSZ_REG_V29: root::sysz_reg = 96;
    pub const sysz_reg_SYSZ_REG_V30: root::sysz_reg = 97;
    pub const sysz_reg_SYSZ_REG_V31: root::sysz_reg = 98;
    pub const sysz_reg_SYSZ_REG_F16: root::sysz_reg = 99;
    pub const sysz_reg_SYSZ_REG_F17: root::sysz_reg = 100;
    pub const sysz_reg_SYSZ_REG_F18: root::sysz_reg = 101;
    pub const sysz_reg_SYSZ_REG_F19: root::sysz_reg = 102;
    pub const sysz_reg_SYSZ_REG_F20: root::sysz_reg = 103;
    pub const sysz_reg_SYSZ_REG_F21: root::sysz_reg = 104;
    pub const sysz_reg_SYSZ_REG_F22: root::sysz_reg = 105;
    pub const sysz_reg_SYSZ_REG_F23: root::sysz_reg = 106;
    pub const sysz_reg_SYSZ_REG_F24: root::sysz_reg = 107;
    pub const sysz_reg_SYSZ_REG_F25: root::sysz_reg = 108;
    pub const sysz_reg_SYSZ_REG_F26: root::sysz_reg = 109;
    pub const sysz_reg_SYSZ_REG_F27: root::sysz_reg = 110;
    pub const sysz_reg_SYSZ_REG_F28: root::sysz_reg = 111;
    pub const sysz_reg_SYSZ_REG_F29: root::sysz_reg = 112;
    pub const sysz_reg_SYSZ_REG_F30: root::sysz_reg = 113;
    pub const sysz_reg_SYSZ_REG_F31: root::sysz_reg = 114;
    pub const sysz_reg_SYSZ_REG_F0Q: root::sysz_reg = 115;
    pub const sysz_reg_SYSZ_REG_F4Q: root::sysz_reg = 116;
    pub const sysz_reg_SYSZ_REG_ENDING: root::sysz_reg = 117;
    #[doc = " SystemZ registers"]
    pub type sysz_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with SYSZ_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sysz_op_mem {
        #[doc = "< base register, can be safely interpreted as"]
        #[doc = "< a value of type `sysz_reg`, but it is only"]
        #[doc = "< one byte wide"]
        pub base: u8,
        #[doc = "< index register, same conditions apply here"]
        pub index: u8,
        #[doc = "< BDLAddr operand"]
        pub length: u64,
        #[doc = "< displacement/offset value"]
        pub disp: i64,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_sysz_op {
        #[doc = "< operand type"]
        pub type_: root::sysz_op_type,
        pub __bindgen_anon_1: root::cs_sysz_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_sysz_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: root::sysz_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i64,
        #[doc = "< base/disp value for MEM operand"]
        pub mem: root::sysz_op_mem,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_sysz {
        #[doc = "< Code condition"]
        pub cc: root::sysz_cc,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_sysz_op; 6usize],
    }
    pub const x86_reg_X86_REG_INVALID: root::x86_reg = 0;
    pub const x86_reg_X86_REG_AH: root::x86_reg = 1;
    pub const x86_reg_X86_REG_AL: root::x86_reg = 2;
    pub const x86_reg_X86_REG_AX: root::x86_reg = 3;
    pub const x86_reg_X86_REG_BH: root::x86_reg = 4;
    pub const x86_reg_X86_REG_BL: root::x86_reg = 5;
    pub const x86_reg_X86_REG_BP: root::x86_reg = 6;
    pub const x86_reg_X86_REG_BPL: root::x86_reg = 7;
    pub const x86_reg_X86_REG_BX: root::x86_reg = 8;
    pub const x86_reg_X86_REG_CH: root::x86_reg = 9;
    pub const x86_reg_X86_REG_CL: root::x86_reg = 10;
    pub const x86_reg_X86_REG_CS: root::x86_reg = 11;
    pub const x86_reg_X86_REG_CX: root::x86_reg = 12;
    pub const x86_reg_X86_REG_DH: root::x86_reg = 13;
    pub const x86_reg_X86_REG_DI: root::x86_reg = 14;
    pub const x86_reg_X86_REG_DIL: root::x86_reg = 15;
    pub const x86_reg_X86_REG_DL: root::x86_reg = 16;
    pub const x86_reg_X86_REG_DS: root::x86_reg = 17;
    pub const x86_reg_X86_REG_DX: root::x86_reg = 18;
    pub const x86_reg_X86_REG_EAX: root::x86_reg = 19;
    pub const x86_reg_X86_REG_EBP: root::x86_reg = 20;
    pub const x86_reg_X86_REG_EBX: root::x86_reg = 21;
    pub const x86_reg_X86_REG_ECX: root::x86_reg = 22;
    pub const x86_reg_X86_REG_EDI: root::x86_reg = 23;
    pub const x86_reg_X86_REG_EDX: root::x86_reg = 24;
    pub const x86_reg_X86_REG_EFLAGS: root::x86_reg = 25;
    pub const x86_reg_X86_REG_EIP: root::x86_reg = 26;
    pub const x86_reg_X86_REG_EIZ: root::x86_reg = 27;
    pub const x86_reg_X86_REG_ES: root::x86_reg = 28;
    pub const x86_reg_X86_REG_ESI: root::x86_reg = 29;
    pub const x86_reg_X86_REG_ESP: root::x86_reg = 30;
    pub const x86_reg_X86_REG_FPSW: root::x86_reg = 31;
    pub const x86_reg_X86_REG_FS: root::x86_reg = 32;
    pub const x86_reg_X86_REG_GS: root::x86_reg = 33;
    pub const x86_reg_X86_REG_IP: root::x86_reg = 34;
    pub const x86_reg_X86_REG_RAX: root::x86_reg = 35;
    pub const x86_reg_X86_REG_RBP: root::x86_reg = 36;
    pub const x86_reg_X86_REG_RBX: root::x86_reg = 37;
    pub const x86_reg_X86_REG_RCX: root::x86_reg = 38;
    pub const x86_reg_X86_REG_RDI: root::x86_reg = 39;
    pub const x86_reg_X86_REG_RDX: root::x86_reg = 40;
    pub const x86_reg_X86_REG_RIP: root::x86_reg = 41;
    pub const x86_reg_X86_REG_RIZ: root::x86_reg = 42;
    pub const x86_reg_X86_REG_RSI: root::x86_reg = 43;
    pub const x86_reg_X86_REG_RSP: root::x86_reg = 44;
    pub const x86_reg_X86_REG_SI: root::x86_reg = 45;
    pub const x86_reg_X86_REG_SIL: root::x86_reg = 46;
    pub const x86_reg_X86_REG_SP: root::x86_reg = 47;
    pub const x86_reg_X86_REG_SPL: root::x86_reg = 48;
    pub const x86_reg_X86_REG_SS: root::x86_reg = 49;
    pub const x86_reg_X86_REG_CR0: root::x86_reg = 50;
    pub const x86_reg_X86_REG_CR1: root::x86_reg = 51;
    pub const x86_reg_X86_REG_CR2: root::x86_reg = 52;
    pub const x86_reg_X86_REG_CR3: root::x86_reg = 53;
    pub const x86_reg_X86_REG_CR4: root::x86_reg = 54;
    pub const x86_reg_X86_REG_CR5: root::x86_reg = 55;
    pub const x86_reg_X86_REG_CR6: root::x86_reg = 56;
    pub const x86_reg_X86_REG_CR7: root::x86_reg = 57;
    pub const x86_reg_X86_REG_CR8: root::x86_reg = 58;
    pub const x86_reg_X86_REG_CR9: root::x86_reg = 59;
    pub const x86_reg_X86_REG_CR10: root::x86_reg = 60;
    pub const x86_reg_X86_REG_CR11: root::x86_reg = 61;
    pub const x86_reg_X86_REG_CR12: root::x86_reg = 62;
    pub const x86_reg_X86_REG_CR13: root::x86_reg = 63;
    pub const x86_reg_X86_REG_CR14: root::x86_reg = 64;
    pub const x86_reg_X86_REG_CR15: root::x86_reg = 65;
    pub const x86_reg_X86_REG_DR0: root::x86_reg = 66;
    pub const x86_reg_X86_REG_DR1: root::x86_reg = 67;
    pub const x86_reg_X86_REG_DR2: root::x86_reg = 68;
    pub const x86_reg_X86_REG_DR3: root::x86_reg = 69;
    pub const x86_reg_X86_REG_DR4: root::x86_reg = 70;
    pub const x86_reg_X86_REG_DR5: root::x86_reg = 71;
    pub const x86_reg_X86_REG_DR6: root::x86_reg = 72;
    pub const x86_reg_X86_REG_DR7: root::x86_reg = 73;
    pub const x86_reg_X86_REG_DR8: root::x86_reg = 74;
    pub const x86_reg_X86_REG_DR9: root::x86_reg = 75;
    pub const x86_reg_X86_REG_DR10: root::x86_reg = 76;
    pub const x86_reg_X86_REG_DR11: root::x86_reg = 77;
    pub const x86_reg_X86_REG_DR12: root::x86_reg = 78;
    pub const x86_reg_X86_REG_DR13: root::x86_reg = 79;
    pub const x86_reg_X86_REG_DR14: root::x86_reg = 80;
    pub const x86_reg_X86_REG_DR15: root::x86_reg = 81;
    pub const x86_reg_X86_REG_FP0: root::x86_reg = 82;
    pub const x86_reg_X86_REG_FP1: root::x86_reg = 83;
    pub const x86_reg_X86_REG_FP2: root::x86_reg = 84;
    pub const x86_reg_X86_REG_FP3: root::x86_reg = 85;
    pub const x86_reg_X86_REG_FP4: root::x86_reg = 86;
    pub const x86_reg_X86_REG_FP5: root::x86_reg = 87;
    pub const x86_reg_X86_REG_FP6: root::x86_reg = 88;
    pub const x86_reg_X86_REG_FP7: root::x86_reg = 89;
    pub const x86_reg_X86_REG_K0: root::x86_reg = 90;
    pub const x86_reg_X86_REG_K1: root::x86_reg = 91;
    pub const x86_reg_X86_REG_K2: root::x86_reg = 92;
    pub const x86_reg_X86_REG_K3: root::x86_reg = 93;
    pub const x86_reg_X86_REG_K4: root::x86_reg = 94;
    pub const x86_reg_X86_REG_K5: root::x86_reg = 95;
    pub const x86_reg_X86_REG_K6: root::x86_reg = 96;
    pub const x86_reg_X86_REG_K7: root::x86_reg = 97;
    pub const x86_reg_X86_REG_MM0: root::x86_reg = 98;
    pub const x86_reg_X86_REG_MM1: root::x86_reg = 99;
    pub const x86_reg_X86_REG_MM2: root::x86_reg = 100;
    pub const x86_reg_X86_REG_MM3: root::x86_reg = 101;
    pub const x86_reg_X86_REG_MM4: root::x86_reg = 102;
    pub const x86_reg_X86_REG_MM5: root::x86_reg = 103;
    pub const x86_reg_X86_REG_MM6: root::x86_reg = 104;
    pub const x86_reg_X86_REG_MM7: root::x86_reg = 105;
    pub const x86_reg_X86_REG_R8: root::x86_reg = 106;
    pub const x86_reg_X86_REG_R9: root::x86_reg = 107;
    pub const x86_reg_X86_REG_R10: root::x86_reg = 108;
    pub const x86_reg_X86_REG_R11: root::x86_reg = 109;
    pub const x86_reg_X86_REG_R12: root::x86_reg = 110;
    pub const x86_reg_X86_REG_R13: root::x86_reg = 111;
    pub const x86_reg_X86_REG_R14: root::x86_reg = 112;
    pub const x86_reg_X86_REG_R15: root::x86_reg = 113;
    pub const x86_reg_X86_REG_ST0: root::x86_reg = 114;
    pub const x86_reg_X86_REG_ST1: root::x86_reg = 115;
    pub const x86_reg_X86_REG_ST2: root::x86_reg = 116;
    pub const x86_reg_X86_REG_ST3: root::x86_reg = 117;
    pub const x86_reg_X86_REG_ST4: root::x86_reg = 118;
    pub const x86_reg_X86_REG_ST5: root::x86_reg = 119;
    pub const x86_reg_X86_REG_ST6: root::x86_reg = 120;
    pub const x86_reg_X86_REG_ST7: root::x86_reg = 121;
    pub const x86_reg_X86_REG_XMM0: root::x86_reg = 122;
    pub const x86_reg_X86_REG_XMM1: root::x86_reg = 123;
    pub const x86_reg_X86_REG_XMM2: root::x86_reg = 124;
    pub const x86_reg_X86_REG_XMM3: root::x86_reg = 125;
    pub const x86_reg_X86_REG_XMM4: root::x86_reg = 126;
    pub const x86_reg_X86_REG_XMM5: root::x86_reg = 127;
    pub const x86_reg_X86_REG_XMM6: root::x86_reg = 128;
    pub const x86_reg_X86_REG_XMM7: root::x86_reg = 129;
    pub const x86_reg_X86_REG_XMM8: root::x86_reg = 130;
    pub const x86_reg_X86_REG_XMM9: root::x86_reg = 131;
    pub const x86_reg_X86_REG_XMM10: root::x86_reg = 132;
    pub const x86_reg_X86_REG_XMM11: root::x86_reg = 133;
    pub const x86_reg_X86_REG_XMM12: root::x86_reg = 134;
    pub const x86_reg_X86_REG_XMM13: root::x86_reg = 135;
    pub const x86_reg_X86_REG_XMM14: root::x86_reg = 136;
    pub const x86_reg_X86_REG_XMM15: root::x86_reg = 137;
    pub const x86_reg_X86_REG_XMM16: root::x86_reg = 138;
    pub const x86_reg_X86_REG_XMM17: root::x86_reg = 139;
    pub const x86_reg_X86_REG_XMM18: root::x86_reg = 140;
    pub const x86_reg_X86_REG_XMM19: root::x86_reg = 141;
    pub const x86_reg_X86_REG_XMM20: root::x86_reg = 142;
    pub const x86_reg_X86_REG_XMM21: root::x86_reg = 143;
    pub const x86_reg_X86_REG_XMM22: root::x86_reg = 144;
    pub const x86_reg_X86_REG_XMM23: root::x86_reg = 145;
    pub const x86_reg_X86_REG_XMM24: root::x86_reg = 146;
    pub const x86_reg_X86_REG_XMM25: root::x86_reg = 147;
    pub const x86_reg_X86_REG_XMM26: root::x86_reg = 148;
    pub const x86_reg_X86_REG_XMM27: root::x86_reg = 149;
    pub const x86_reg_X86_REG_XMM28: root::x86_reg = 150;
    pub const x86_reg_X86_REG_XMM29: root::x86_reg = 151;
    pub const x86_reg_X86_REG_XMM30: root::x86_reg = 152;
    pub const x86_reg_X86_REG_XMM31: root::x86_reg = 153;
    pub const x86_reg_X86_REG_YMM0: root::x86_reg = 154;
    pub const x86_reg_X86_REG_YMM1: root::x86_reg = 155;
    pub const x86_reg_X86_REG_YMM2: root::x86_reg = 156;
    pub const x86_reg_X86_REG_YMM3: root::x86_reg = 157;
    pub const x86_reg_X86_REG_YMM4: root::x86_reg = 158;
    pub const x86_reg_X86_REG_YMM5: root::x86_reg = 159;
    pub const x86_reg_X86_REG_YMM6: root::x86_reg = 160;
    pub const x86_reg_X86_REG_YMM7: root::x86_reg = 161;
    pub const x86_reg_X86_REG_YMM8: root::x86_reg = 162;
    pub const x86_reg_X86_REG_YMM9: root::x86_reg = 163;
    pub const x86_reg_X86_REG_YMM10: root::x86_reg = 164;
    pub const x86_reg_X86_REG_YMM11: root::x86_reg = 165;
    pub const x86_reg_X86_REG_YMM12: root::x86_reg = 166;
    pub const x86_reg_X86_REG_YMM13: root::x86_reg = 167;
    pub const x86_reg_X86_REG_YMM14: root::x86_reg = 168;
    pub const x86_reg_X86_REG_YMM15: root::x86_reg = 169;
    pub const x86_reg_X86_REG_YMM16: root::x86_reg = 170;
    pub const x86_reg_X86_REG_YMM17: root::x86_reg = 171;
    pub const x86_reg_X86_REG_YMM18: root::x86_reg = 172;
    pub const x86_reg_X86_REG_YMM19: root::x86_reg = 173;
    pub const x86_reg_X86_REG_YMM20: root::x86_reg = 174;
    pub const x86_reg_X86_REG_YMM21: root::x86_reg = 175;
    pub const x86_reg_X86_REG_YMM22: root::x86_reg = 176;
    pub const x86_reg_X86_REG_YMM23: root::x86_reg = 177;
    pub const x86_reg_X86_REG_YMM24: root::x86_reg = 178;
    pub const x86_reg_X86_REG_YMM25: root::x86_reg = 179;
    pub const x86_reg_X86_REG_YMM26: root::x86_reg = 180;
    pub const x86_reg_X86_REG_YMM27: root::x86_reg = 181;
    pub const x86_reg_X86_REG_YMM28: root::x86_reg = 182;
    pub const x86_reg_X86_REG_YMM29: root::x86_reg = 183;
    pub const x86_reg_X86_REG_YMM30: root::x86_reg = 184;
    pub const x86_reg_X86_REG_YMM31: root::x86_reg = 185;
    pub const x86_reg_X86_REG_ZMM0: root::x86_reg = 186;
    pub const x86_reg_X86_REG_ZMM1: root::x86_reg = 187;
    pub const x86_reg_X86_REG_ZMM2: root::x86_reg = 188;
    pub const x86_reg_X86_REG_ZMM3: root::x86_reg = 189;
    pub const x86_reg_X86_REG_ZMM4: root::x86_reg = 190;
    pub const x86_reg_X86_REG_ZMM5: root::x86_reg = 191;
    pub const x86_reg_X86_REG_ZMM6: root::x86_reg = 192;
    pub const x86_reg_X86_REG_ZMM7: root::x86_reg = 193;
    pub const x86_reg_X86_REG_ZMM8: root::x86_reg = 194;
    pub const x86_reg_X86_REG_ZMM9: root::x86_reg = 195;
    pub const x86_reg_X86_REG_ZMM10: root::x86_reg = 196;
    pub const x86_reg_X86_REG_ZMM11: root::x86_reg = 197;
    pub const x86_reg_X86_REG_ZMM12: root::x86_reg = 198;
    pub const x86_reg_X86_REG_ZMM13: root::x86_reg = 199;
    pub const x86_reg_X86_REG_ZMM14: root::x86_reg = 200;
    pub const x86_reg_X86_REG_ZMM15: root::x86_reg = 201;
    pub const x86_reg_X86_REG_ZMM16: root::x86_reg = 202;
    pub const x86_reg_X86_REG_ZMM17: root::x86_reg = 203;
    pub const x86_reg_X86_REG_ZMM18: root::x86_reg = 204;
    pub const x86_reg_X86_REG_ZMM19: root::x86_reg = 205;
    pub const x86_reg_X86_REG_ZMM20: root::x86_reg = 206;
    pub const x86_reg_X86_REG_ZMM21: root::x86_reg = 207;
    pub const x86_reg_X86_REG_ZMM22: root::x86_reg = 208;
    pub const x86_reg_X86_REG_ZMM23: root::x86_reg = 209;
    pub const x86_reg_X86_REG_ZMM24: root::x86_reg = 210;
    pub const x86_reg_X86_REG_ZMM25: root::x86_reg = 211;
    pub const x86_reg_X86_REG_ZMM26: root::x86_reg = 212;
    pub const x86_reg_X86_REG_ZMM27: root::x86_reg = 213;
    pub const x86_reg_X86_REG_ZMM28: root::x86_reg = 214;
    pub const x86_reg_X86_REG_ZMM29: root::x86_reg = 215;
    pub const x86_reg_X86_REG_ZMM30: root::x86_reg = 216;
    pub const x86_reg_X86_REG_ZMM31: root::x86_reg = 217;
    pub const x86_reg_X86_REG_R8B: root::x86_reg = 218;
    pub const x86_reg_X86_REG_R9B: root::x86_reg = 219;
    pub const x86_reg_X86_REG_R10B: root::x86_reg = 220;
    pub const x86_reg_X86_REG_R11B: root::x86_reg = 221;
    pub const x86_reg_X86_REG_R12B: root::x86_reg = 222;
    pub const x86_reg_X86_REG_R13B: root::x86_reg = 223;
    pub const x86_reg_X86_REG_R14B: root::x86_reg = 224;
    pub const x86_reg_X86_REG_R15B: root::x86_reg = 225;
    pub const x86_reg_X86_REG_R8D: root::x86_reg = 226;
    pub const x86_reg_X86_REG_R9D: root::x86_reg = 227;
    pub const x86_reg_X86_REG_R10D: root::x86_reg = 228;
    pub const x86_reg_X86_REG_R11D: root::x86_reg = 229;
    pub const x86_reg_X86_REG_R12D: root::x86_reg = 230;
    pub const x86_reg_X86_REG_R13D: root::x86_reg = 231;
    pub const x86_reg_X86_REG_R14D: root::x86_reg = 232;
    pub const x86_reg_X86_REG_R15D: root::x86_reg = 233;
    pub const x86_reg_X86_REG_R8W: root::x86_reg = 234;
    pub const x86_reg_X86_REG_R9W: root::x86_reg = 235;
    pub const x86_reg_X86_REG_R10W: root::x86_reg = 236;
    pub const x86_reg_X86_REG_R11W: root::x86_reg = 237;
    pub const x86_reg_X86_REG_R12W: root::x86_reg = 238;
    pub const x86_reg_X86_REG_R13W: root::x86_reg = 239;
    pub const x86_reg_X86_REG_R14W: root::x86_reg = 240;
    pub const x86_reg_X86_REG_R15W: root::x86_reg = 241;
    pub const x86_reg_X86_REG_BND0: root::x86_reg = 242;
    pub const x86_reg_X86_REG_BND1: root::x86_reg = 243;
    pub const x86_reg_X86_REG_BND2: root::x86_reg = 244;
    pub const x86_reg_X86_REG_BND3: root::x86_reg = 245;
    pub const x86_reg_X86_REG_ENDING: root::x86_reg = 246;
    #[doc = " X86 registers"]
    pub type x86_reg = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const x86_op_type_X86_OP_INVALID: root::x86_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const x86_op_type_X86_OP_REG: root::x86_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const x86_op_type_X86_OP_IMM: root::x86_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const x86_op_type_X86_OP_MEM: root::x86_op_type = 3;
    #[doc = " Operand type for instruction's operands"]
    pub type x86_op_type = cty::c_int;
    #[doc = "< Uninitialized."]
    pub const x86_xop_cc_X86_XOP_CC_INVALID: root::x86_xop_cc = 0;
    pub const x86_xop_cc_X86_XOP_CC_LT: root::x86_xop_cc = 1;
    pub const x86_xop_cc_X86_XOP_CC_LE: root::x86_xop_cc = 2;
    pub const x86_xop_cc_X86_XOP_CC_GT: root::x86_xop_cc = 3;
    pub const x86_xop_cc_X86_XOP_CC_GE: root::x86_xop_cc = 4;
    pub const x86_xop_cc_X86_XOP_CC_EQ: root::x86_xop_cc = 5;
    pub const x86_xop_cc_X86_XOP_CC_NEQ: root::x86_xop_cc = 6;
    pub const x86_xop_cc_X86_XOP_CC_FALSE: root::x86_xop_cc = 7;
    pub const x86_xop_cc_X86_XOP_CC_TRUE: root::x86_xop_cc = 8;
    #[doc = " XOP Code Condition type"]
    pub type x86_xop_cc = cty::c_int;
    #[doc = "< Uninitialized."]
    pub const x86_avx_bcast_X86_AVX_BCAST_INVALID: root::x86_avx_bcast = 0;
    #[doc = "< AVX512 broadcast type {1to2}"]
    pub const x86_avx_bcast_X86_AVX_BCAST_2: root::x86_avx_bcast = 1;
    #[doc = "< AVX512 broadcast type {1to4}"]
    pub const x86_avx_bcast_X86_AVX_BCAST_4: root::x86_avx_bcast = 2;
    #[doc = "< AVX512 broadcast type {1to8}"]
    pub const x86_avx_bcast_X86_AVX_BCAST_8: root::x86_avx_bcast = 3;
    #[doc = "< AVX512 broadcast type {1to16}"]
    pub const x86_avx_bcast_X86_AVX_BCAST_16: root::x86_avx_bcast = 4;
    #[doc = " AVX broadcast type"]
    pub type x86_avx_bcast = cty::c_int;
    #[doc = "< Uninitialized."]
    pub const x86_sse_cc_X86_SSE_CC_INVALID: root::x86_sse_cc = 0;
    pub const x86_sse_cc_X86_SSE_CC_EQ: root::x86_sse_cc = 1;
    pub const x86_sse_cc_X86_SSE_CC_LT: root::x86_sse_cc = 2;
    pub const x86_sse_cc_X86_SSE_CC_LE: root::x86_sse_cc = 3;
    pub const x86_sse_cc_X86_SSE_CC_UNORD: root::x86_sse_cc = 4;
    pub const x86_sse_cc_X86_SSE_CC_NEQ: root::x86_sse_cc = 5;
    pub const x86_sse_cc_X86_SSE_CC_NLT: root::x86_sse_cc = 6;
    pub const x86_sse_cc_X86_SSE_CC_NLE: root::x86_sse_cc = 7;
    pub const x86_sse_cc_X86_SSE_CC_ORD: root::x86_sse_cc = 8;
    #[doc = " SSE Code Condition type"]
    pub type x86_sse_cc = cty::c_int;
    #[doc = "< Uninitialized."]
    pub const x86_avx_cc_X86_AVX_CC_INVALID: root::x86_avx_cc = 0;
    pub const x86_avx_cc_X86_AVX_CC_EQ: root::x86_avx_cc = 1;
    pub const x86_avx_cc_X86_AVX_CC_LT: root::x86_avx_cc = 2;
    pub const x86_avx_cc_X86_AVX_CC_LE: root::x86_avx_cc = 3;
    pub const x86_avx_cc_X86_AVX_CC_UNORD: root::x86_avx_cc = 4;
    pub const x86_avx_cc_X86_AVX_CC_NEQ: root::x86_avx_cc = 5;
    pub const x86_avx_cc_X86_AVX_CC_NLT: root::x86_avx_cc = 6;
    pub const x86_avx_cc_X86_AVX_CC_NLE: root::x86_avx_cc = 7;
    pub const x86_avx_cc_X86_AVX_CC_ORD: root::x86_avx_cc = 8;
    pub const x86_avx_cc_X86_AVX_CC_EQ_UQ: root::x86_avx_cc = 9;
    pub const x86_avx_cc_X86_AVX_CC_NGE: root::x86_avx_cc = 10;
    pub const x86_avx_cc_X86_AVX_CC_NGT: root::x86_avx_cc = 11;
    pub const x86_avx_cc_X86_AVX_CC_FALSE: root::x86_avx_cc = 12;
    pub const x86_avx_cc_X86_AVX_CC_NEQ_OQ: root::x86_avx_cc = 13;
    pub const x86_avx_cc_X86_AVX_CC_GE: root::x86_avx_cc = 14;
    pub const x86_avx_cc_X86_AVX_CC_GT: root::x86_avx_cc = 15;
    pub const x86_avx_cc_X86_AVX_CC_TRUE: root::x86_avx_cc = 16;
    pub const x86_avx_cc_X86_AVX_CC_EQ_OS: root::x86_avx_cc = 17;
    pub const x86_avx_cc_X86_AVX_CC_LT_OQ: root::x86_avx_cc = 18;
    pub const x86_avx_cc_X86_AVX_CC_LE_OQ: root::x86_avx_cc = 19;
    pub const x86_avx_cc_X86_AVX_CC_UNORD_S: root::x86_avx_cc = 20;
    pub const x86_avx_cc_X86_AVX_CC_NEQ_US: root::x86_avx_cc = 21;
    pub const x86_avx_cc_X86_AVX_CC_NLT_UQ: root::x86_avx_cc = 22;
    pub const x86_avx_cc_X86_AVX_CC_NLE_UQ: root::x86_avx_cc = 23;
    pub const x86_avx_cc_X86_AVX_CC_ORD_S: root::x86_avx_cc = 24;
    pub const x86_avx_cc_X86_AVX_CC_EQ_US: root::x86_avx_cc = 25;
    pub const x86_avx_cc_X86_AVX_CC_NGE_UQ: root::x86_avx_cc = 26;
    pub const x86_avx_cc_X86_AVX_CC_NGT_UQ: root::x86_avx_cc = 27;
    pub const x86_avx_cc_X86_AVX_CC_FALSE_OS: root::x86_avx_cc = 28;
    pub const x86_avx_cc_X86_AVX_CC_NEQ_OS: root::x86_avx_cc = 29;
    pub const x86_avx_cc_X86_AVX_CC_GE_OQ: root::x86_avx_cc = 30;
    pub const x86_avx_cc_X86_AVX_CC_GT_OQ: root::x86_avx_cc = 31;
    pub const x86_avx_cc_X86_AVX_CC_TRUE_US: root::x86_avx_cc = 32;
    #[doc = " AVX Code Condition type"]
    pub type x86_avx_cc = cty::c_int;
    #[doc = "< Uninitialized."]
    pub const x86_avx_rm_X86_AVX_RM_INVALID: root::x86_avx_rm = 0;
    #[doc = "< Round to nearest"]
    pub const x86_avx_rm_X86_AVX_RM_RN: root::x86_avx_rm = 1;
    #[doc = "< Round down"]
    pub const x86_avx_rm_X86_AVX_RM_RD: root::x86_avx_rm = 2;
    #[doc = "< Round up"]
    pub const x86_avx_rm_X86_AVX_RM_RU: root::x86_avx_rm = 3;
    #[doc = "< Round toward zero"]
    pub const x86_avx_rm_X86_AVX_RM_RZ: root::x86_avx_rm = 4;
    #[doc = " AVX static rounding mode type"]
    pub type x86_avx_rm = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with X86_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct x86_op_mem {
        #[doc = "< segment register (or X86_REG_INVALID if irrelevant)"]
        pub segment: root::x86_reg,
        #[doc = "< base register (or X86_REG_INVALID if irrelevant)"]
        pub base: root::x86_reg,
        #[doc = "< index register (or X86_REG_INVALID if irrelevant)"]
        pub index: root::x86_reg,
        #[doc = "< scale for index register"]
        pub scale: cty::c_int,
        #[doc = "< displacement value"]
        pub disp: i64,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_x86_op {
        #[doc = "< operand type"]
        pub type_: root::x86_op_type,
        pub __bindgen_anon_1: root::cs_x86_op__bindgen_ty_1,
        #[doc = " size of this operand (in bytes)."]
        pub size: u8,
        #[doc = " How is this operand accessed? (READ, WRITE or READ|WRITE)"]
        #[doc = " This field is combined of cs_ac_type."]
        #[doc = " NOTE: this field is irrelevant if engine is compiled in DIET mode."]
        pub access: u8,
        #[doc = " AVX broadcast type, or 0 if irrelevant"]
        pub avx_bcast: root::x86_avx_bcast,
        #[doc = " AVX zero opmask {z}"]
        pub avx_zero_opmask: bool,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_x86_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: root::x86_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i64,
        #[doc = "< base/index/scale/disp value for MEM operand"]
        pub mem: root::x86_op_mem,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_x86_encoding {
        #[doc = " ModR/M offset, or 0 when irrelevant"]
        pub modrm_offset: u8,
        #[doc = " Displacement offset, or 0 when irrelevant."]
        pub disp_offset: u8,
        pub disp_size: u8,
        #[doc = " Immediate offset, or 0 when irrelevant."]
        pub imm_offset: u8,
        pub imm_size: u8,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_x86 {
        #[doc = " Instruction prefix, which can be up to 4 bytes."]
        #[doc = " A prefix byte gets value 0 when irrelevant."]
        #[doc = " prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)"]
        #[doc = " prefix[1] indicates segment override (irrelevant for x86_64):"]
        #[doc = " See X86_PREFIX_CS/SS/DS/ES/FS/GS above."]
        #[doc = " prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)"]
        #[doc = " prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)"]
        pub prefix: [u8; 4usize],
        #[doc = " Instruction opcode, which can be from 1 to 4 bytes in size."]
        #[doc = " This contains VEX opcode as well."]
        #[doc = " An trailing opcode byte gets value 0 when irrelevant."]
        pub opcode: [u8; 4usize],
        #[doc = " REX prefix: only a non-zero value is relevant for x86_64"]
        pub rex: u8,
        #[doc = " Address size, which can be overridden with above prefix[5]."]
        pub addr_size: u8,
        #[doc = " ModR/M byte"]
        pub modrm: u8,
        #[doc = " SIB value, or 0 when irrelevant."]
        pub sib: u8,
        #[doc = " Displacement value, valid if encoding.disp_offset != 0"]
        pub disp: i64,
        #[doc = " SIB index register, or X86_REG_INVALID when irrelevant."]
        pub sib_index: root::x86_reg,
        #[doc = " SIB scale, only applicable if sib_index is valid."]
        pub sib_scale: i8,
        #[doc = " SIB base register, or X86_REG_INVALID when irrelevant."]
        pub sib_base: root::x86_reg,
        #[doc = " XOP Code Condition"]
        pub xop_cc: root::x86_xop_cc,
        #[doc = " SSE Code Condition"]
        pub sse_cc: root::x86_sse_cc,
        #[doc = " AVX Code Condition"]
        pub avx_cc: root::x86_avx_cc,
        #[doc = " AVX Suppress all Exception"]
        pub avx_sae: bool,
        #[doc = " AVX static rounding mode"]
        pub avx_rm: root::x86_avx_rm,
        pub __bindgen_anon_1: root::cs_x86__bindgen_ty_1,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_x86_op; 8usize],
        #[doc = "< encoding information"]
        pub encoding: root::cs_x86_encoding,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_x86__bindgen_ty_1 {
        #[doc = " EFLAGS updated by this instruction."]
        #[doc = " This can be formed from OR combination of X86_EFLAGS_* symbols in x86.h"]
        pub eflags: u64,
        #[doc = " FPU_FLAGS updated by this instruction."]
        #[doc = " This can be formed from OR combination of X86_FPU_FLAGS_* symbols in x86.h"]
        pub fpu_flags: u64,
    }
    #[doc = "< = CS_GRP_INVALID"]
    pub const x86_insn_group_X86_GRP_INVALID: root::x86_insn_group = 0;
    #[doc = "< = CS_GRP_JUMP"]
    pub const x86_insn_group_X86_GRP_JUMP: root::x86_insn_group = 1;
    #[doc = "< = CS_GRP_CALL"]
    pub const x86_insn_group_X86_GRP_CALL: root::x86_insn_group = 2;
    #[doc = "< = CS_GRP_RET"]
    pub const x86_insn_group_X86_GRP_RET: root::x86_insn_group = 3;
    #[doc = "< = CS_GRP_INT"]
    pub const x86_insn_group_X86_GRP_INT: root::x86_insn_group = 4;
    #[doc = "< = CS_GRP_IRET"]
    pub const x86_insn_group_X86_GRP_IRET: root::x86_insn_group = 5;
    #[doc = "< = CS_GRP_PRIVILEGE"]
    pub const x86_insn_group_X86_GRP_PRIVILEGE: root::x86_insn_group = 6;
    #[doc = "< = CS_GRP_BRANCH_RELATIVE"]
    pub const x86_insn_group_X86_GRP_BRANCH_RELATIVE: root::x86_insn_group = 7;
    #[doc = "< all virtualization instructions (VT-x + AMD-V)"]
    pub const x86_insn_group_X86_GRP_VM: root::x86_insn_group = 128;
    pub const x86_insn_group_X86_GRP_3DNOW: root::x86_insn_group = 129;
    pub const x86_insn_group_X86_GRP_AES: root::x86_insn_group = 130;
    pub const x86_insn_group_X86_GRP_ADX: root::x86_insn_group = 131;
    pub const x86_insn_group_X86_GRP_AVX: root::x86_insn_group = 132;
    pub const x86_insn_group_X86_GRP_AVX2: root::x86_insn_group = 133;
    pub const x86_insn_group_X86_GRP_AVX512: root::x86_insn_group = 134;
    pub const x86_insn_group_X86_GRP_BMI: root::x86_insn_group = 135;
    pub const x86_insn_group_X86_GRP_BMI2: root::x86_insn_group = 136;
    pub const x86_insn_group_X86_GRP_CMOV: root::x86_insn_group = 137;
    pub const x86_insn_group_X86_GRP_F16C: root::x86_insn_group = 138;
    pub const x86_insn_group_X86_GRP_FMA: root::x86_insn_group = 139;
    pub const x86_insn_group_X86_GRP_FMA4: root::x86_insn_group = 140;
    pub const x86_insn_group_X86_GRP_FSGSBASE: root::x86_insn_group = 141;
    pub const x86_insn_group_X86_GRP_HLE: root::x86_insn_group = 142;
    pub const x86_insn_group_X86_GRP_MMX: root::x86_insn_group = 143;
    pub const x86_insn_group_X86_GRP_MODE32: root::x86_insn_group = 144;
    pub const x86_insn_group_X86_GRP_MODE64: root::x86_insn_group = 145;
    pub const x86_insn_group_X86_GRP_RTM: root::x86_insn_group = 146;
    pub const x86_insn_group_X86_GRP_SHA: root::x86_insn_group = 147;
    pub const x86_insn_group_X86_GRP_SSE1: root::x86_insn_group = 148;
    pub const x86_insn_group_X86_GRP_SSE2: root::x86_insn_group = 149;
    pub const x86_insn_group_X86_GRP_SSE3: root::x86_insn_group = 150;
    pub const x86_insn_group_X86_GRP_SSE41: root::x86_insn_group = 151;
    pub const x86_insn_group_X86_GRP_SSE42: root::x86_insn_group = 152;
    pub const x86_insn_group_X86_GRP_SSE4A: root::x86_insn_group = 153;
    pub const x86_insn_group_X86_GRP_SSSE3: root::x86_insn_group = 154;
    pub const x86_insn_group_X86_GRP_PCLMUL: root::x86_insn_group = 155;
    pub const x86_insn_group_X86_GRP_XOP: root::x86_insn_group = 156;
    pub const x86_insn_group_X86_GRP_CDI: root::x86_insn_group = 157;
    pub const x86_insn_group_X86_GRP_ERI: root::x86_insn_group = 158;
    pub const x86_insn_group_X86_GRP_TBM: root::x86_insn_group = 159;
    pub const x86_insn_group_X86_GRP_16BITMODE: root::x86_insn_group = 160;
    pub const x86_insn_group_X86_GRP_NOT64BITMODE: root::x86_insn_group = 161;
    pub const x86_insn_group_X86_GRP_SGX: root::x86_insn_group = 162;
    pub const x86_insn_group_X86_GRP_DQI: root::x86_insn_group = 163;
    pub const x86_insn_group_X86_GRP_BWI: root::x86_insn_group = 164;
    pub const x86_insn_group_X86_GRP_PFI: root::x86_insn_group = 165;
    pub const x86_insn_group_X86_GRP_VLX: root::x86_insn_group = 166;
    pub const x86_insn_group_X86_GRP_SMAP: root::x86_insn_group = 167;
    pub const x86_insn_group_X86_GRP_NOVLX: root::x86_insn_group = 168;
    pub const x86_insn_group_X86_GRP_FPU: root::x86_insn_group = 169;
    pub const x86_insn_group_X86_GRP_ENDING: root::x86_insn_group = 170;
    #[doc = " Group of X86 instructions"]
    pub type x86_insn_group = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const xcore_op_type_XCORE_OP_INVALID: root::xcore_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const xcore_op_type_XCORE_OP_REG: root::xcore_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const xcore_op_type_XCORE_OP_IMM: root::xcore_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const xcore_op_type_XCORE_OP_MEM: root::xcore_op_type = 3;
    #[doc = " Operand type for instruction's operands"]
    pub type xcore_op_type = cty::c_int;
    pub const xcore_reg_XCORE_REG_INVALID: root::xcore_reg = 0;
    pub const xcore_reg_XCORE_REG_CP: root::xcore_reg = 1;
    pub const xcore_reg_XCORE_REG_DP: root::xcore_reg = 2;
    pub const xcore_reg_XCORE_REG_LR: root::xcore_reg = 3;
    pub const xcore_reg_XCORE_REG_SP: root::xcore_reg = 4;
    pub const xcore_reg_XCORE_REG_R0: root::xcore_reg = 5;
    pub const xcore_reg_XCORE_REG_R1: root::xcore_reg = 6;
    pub const xcore_reg_XCORE_REG_R2: root::xcore_reg = 7;
    pub const xcore_reg_XCORE_REG_R3: root::xcore_reg = 8;
    pub const xcore_reg_XCORE_REG_R4: root::xcore_reg = 9;
    pub const xcore_reg_XCORE_REG_R5: root::xcore_reg = 10;
    pub const xcore_reg_XCORE_REG_R6: root::xcore_reg = 11;
    pub const xcore_reg_XCORE_REG_R7: root::xcore_reg = 12;
    pub const xcore_reg_XCORE_REG_R8: root::xcore_reg = 13;
    pub const xcore_reg_XCORE_REG_R9: root::xcore_reg = 14;
    pub const xcore_reg_XCORE_REG_R10: root::xcore_reg = 15;
    pub const xcore_reg_XCORE_REG_R11: root::xcore_reg = 16;
    #[doc = "< pc"]
    pub const xcore_reg_XCORE_REG_PC: root::xcore_reg = 17;
    #[doc = "< save pc"]
    pub const xcore_reg_XCORE_REG_SCP: root::xcore_reg = 18;
    pub const xcore_reg_XCORE_REG_SSR: root::xcore_reg = 19;
    pub const xcore_reg_XCORE_REG_ET: root::xcore_reg = 20;
    pub const xcore_reg_XCORE_REG_ED: root::xcore_reg = 21;
    pub const xcore_reg_XCORE_REG_SED: root::xcore_reg = 22;
    pub const xcore_reg_XCORE_REG_KEP: root::xcore_reg = 23;
    pub const xcore_reg_XCORE_REG_KSP: root::xcore_reg = 24;
    pub const xcore_reg_XCORE_REG_ID: root::xcore_reg = 25;
    pub const xcore_reg_XCORE_REG_ENDING: root::xcore_reg = 26;
    #[doc = " XCore registers"]
    pub type xcore_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with XCORE_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xcore_op_mem {
        #[doc = "< base register, can be safely interpreted as"]
        #[doc = "< a value of type `xcore_reg`, but it is only"]
        #[doc = "< one byte wide"]
        pub base: u8,
        #[doc = "< index register, same conditions apply here"]
        pub index: u8,
        #[doc = "< displacement/offset value"]
        pub disp: i32,
        #[doc = "< +1: forward, -1: backward"]
        pub direct: cty::c_int,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_xcore_op {
        #[doc = "< operand type"]
        pub type_: root::xcore_op_type,
        pub __bindgen_anon_1: root::cs_xcore_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_xcore_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: root::xcore_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i32,
        #[doc = "< base/disp value for MEM operand"]
        pub mem: root::xcore_op_mem,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_xcore {
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_xcore_op; 8usize],
    }
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const tms320c64x_op_type_TMS320C64X_OP_INVALID: root::tms320c64x_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const tms320c64x_op_type_TMS320C64X_OP_REG: root::tms320c64x_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const tms320c64x_op_type_TMS320C64X_OP_IMM: root::tms320c64x_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const tms320c64x_op_type_TMS320C64X_OP_MEM: root::tms320c64x_op_type = 3;
    #[doc = "< Register pair for double word ops"]
    pub const tms320c64x_op_type_TMS320C64X_OP_REGPAIR: root::tms320c64x_op_type = 64;
    pub type tms320c64x_op_type = cty::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tms320c64x_op_mem {
        #[doc = "< base register"]
        pub base: cty::c_uint,
        #[doc = "< displacement/offset value"]
        pub disp: cty::c_uint,
        #[doc = "< unit of base and offset register"]
        pub unit: cty::c_uint,
        #[doc = "< offset scaled"]
        pub scaled: cty::c_uint,
        #[doc = "< displacement type"]
        pub disptype: cty::c_uint,
        #[doc = "< direction"]
        pub direction: cty::c_uint,
        #[doc = "< modification"]
        pub modify: cty::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_tms320c64x_op {
        #[doc = "< operand type"]
        pub type_: root::tms320c64x_op_type,
        pub __bindgen_anon_1: root::cs_tms320c64x_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_tms320c64x_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand or first register for REGPAIR operand"]
        pub reg: cty::c_uint,
        #[doc = "< immediate value for IMM operand"]
        pub imm: i32,
        #[doc = "< base/disp value for MEM operand"]
        pub mem: root::tms320c64x_op_mem,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_tms320c64x {
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_tms320c64x_op; 8usize],
        pub condition: root::cs_tms320c64x__bindgen_ty_1,
        pub funit: root::cs_tms320c64x__bindgen_ty_2,
        pub parallel: cty::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_tms320c64x__bindgen_ty_1 {
        pub reg: cty::c_uint,
        pub zero: cty::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_tms320c64x__bindgen_ty_2 {
        pub unit: cty::c_uint,
        pub side: cty::c_uint,
        pub crosspath: cty::c_uint,
    }
    pub const m680x_reg_M680X_REG_INVALID: root::m680x_reg = 0;
    #[doc = "< M6800/1/2/3/9, HD6301/9"]
    pub const m680x_reg_M680X_REG_A: root::m680x_reg = 1;
    #[doc = "< M6800/1/2/3/9, HD6301/9"]
    pub const m680x_reg_M680X_REG_B: root::m680x_reg = 2;
    #[doc = "< HD6309"]
    pub const m680x_reg_M680X_REG_E: root::m680x_reg = 3;
    #[doc = "< HD6309"]
    pub const m680x_reg_M680X_REG_F: root::m680x_reg = 4;
    #[doc = "< HD6309"]
    pub const m680x_reg_M680X_REG_0: root::m680x_reg = 5;
    #[doc = "< M6801/3/9, HD6301/9"]
    pub const m680x_reg_M680X_REG_D: root::m680x_reg = 6;
    #[doc = "< HD6309"]
    pub const m680x_reg_M680X_REG_W: root::m680x_reg = 7;
    #[doc = "< M6800/1/2/3/9, M6301/9"]
    pub const m680x_reg_M680X_REG_CC: root::m680x_reg = 8;
    #[doc = "< M6809/M6309"]
    pub const m680x_reg_M680X_REG_DP: root::m680x_reg = 9;
    #[doc = "< M6309"]
    pub const m680x_reg_M680X_REG_MD: root::m680x_reg = 10;
    #[doc = "< M6808"]
    pub const m680x_reg_M680X_REG_HX: root::m680x_reg = 11;
    #[doc = "< M6808"]
    pub const m680x_reg_M680X_REG_H: root::m680x_reg = 12;
    #[doc = "< M6800/1/2/3/9, M6301/9"]
    pub const m680x_reg_M680X_REG_X: root::m680x_reg = 13;
    #[doc = "< M6809/M6309"]
    pub const m680x_reg_M680X_REG_Y: root::m680x_reg = 14;
    #[doc = "< M6809/M6309"]
    pub const m680x_reg_M680X_REG_S: root::m680x_reg = 15;
    #[doc = "< M6809/M6309"]
    pub const m680x_reg_M680X_REG_U: root::m680x_reg = 16;
    #[doc = "< M6309"]
    pub const m680x_reg_M680X_REG_V: root::m680x_reg = 17;
    #[doc = "< M6309"]
    pub const m680x_reg_M680X_REG_Q: root::m680x_reg = 18;
    #[doc = "< M6800/1/2/3/9, M6301/9"]
    pub const m680x_reg_M680X_REG_PC: root::m680x_reg = 19;
    #[doc = "< CPU12"]
    pub const m680x_reg_M680X_REG_TMP2: root::m680x_reg = 20;
    #[doc = "< CPU12"]
    pub const m680x_reg_M680X_REG_TMP3: root::m680x_reg = 21;
    #[doc = "< <-- mark the end of the list of registers"]
    pub const m680x_reg_M680X_REG_ENDING: root::m680x_reg = 22;
    #[doc = " M680X registers and special registers"]
    pub type m680x_reg = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const m680x_op_type_M680X_OP_INVALID: root::m680x_op_type = 0;
    #[doc = "< = Register operand."]
    pub const m680x_op_type_M680X_OP_REGISTER: root::m680x_op_type = 1;
    #[doc = "< = Immediate operand."]
    pub const m680x_op_type_M680X_OP_IMMEDIATE: root::m680x_op_type = 2;
    #[doc = "< = Indexed addressing operand."]
    pub const m680x_op_type_M680X_OP_INDEXED: root::m680x_op_type = 3;
    #[doc = "< = Extended addressing operand."]
    pub const m680x_op_type_M680X_OP_EXTENDED: root::m680x_op_type = 4;
    #[doc = "< = Direct addressing operand."]
    pub const m680x_op_type_M680X_OP_DIRECT: root::m680x_op_type = 5;
    #[doc = "< = Relative addressing operand."]
    pub const m680x_op_type_M680X_OP_RELATIVE: root::m680x_op_type = 6;
    #[doc = "< = constant operand (Displayed as number only)."]
    #[doc = "< Used e.g. for a bit index or page number."]
    pub const m680x_op_type_M680X_OP_CONSTANT: root::m680x_op_type = 7;
    #[doc = " Operand type for instruction's operands"]
    pub type m680x_op_type = cty::c_int;
    #[doc = " Instruction's operand referring to indexed addressing"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct m680x_op_idx {
        #[doc = "< base register (or M680X_REG_INVALID if"]
        #[doc = "< irrelevant)"]
        pub base_reg: root::m680x_reg,
        #[doc = "< offset register (or M680X_REG_INVALID if"]
        #[doc = "< irrelevant)"]
        pub offset_reg: root::m680x_reg,
        #[doc = "< 5-,8- or 16-bit offset. See also offset_bits."]
        pub offset: i16,
        #[doc = "< = offset addr. if base_reg == M680X_REG_PC."]
        #[doc = "< calculated as offset + PC"]
        pub offset_addr: u16,
        #[doc = "< offset width in bits for indexed addressing"]
        pub offset_bits: u8,
        #[doc = "< inc. or dec. value:"]
        #[doc = "<    0: no inc-/decrement"]
        #[doc = "<    1 .. 8: increment by 1 .. 8"]
        #[doc = "<    -1 .. -8: decrement by 1 .. 8"]
        #[doc = "< if flag M680X_IDX_POST_INC_DEC set it is post"]
        #[doc = "< inc-/decrement otherwise pre inc-/decrement"]
        pub inc_dec: i8,
        #[doc = "< 8-bit flags (see above)"]
        pub flags: u8,
    }
    #[doc = " Instruction's memory operand referring to relative addressing (Bcc/LBcc)"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct m680x_op_rel {
        #[doc = "< The absolute address."]
        #[doc = "< calculated as PC + offset. PC is the first"]
        #[doc = "< address after the instruction."]
        pub address: u16,
        #[doc = "< the offset/displacement value"]
        pub offset: i16,
    }
    #[doc = " Instruction's operand referring to extended addressing"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct m680x_op_ext {
        #[doc = "< The absolute address"]
        pub address: u16,
        #[doc = "< true if extended indirect addressing"]
        pub indirect: bool,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_m680x_op {
        pub type_: root::m680x_op_type,
        pub __bindgen_anon_1: root::cs_m680x_op__bindgen_ty_1,
        #[doc = "< size of this operand (in bytes)"]
        pub size: u8,
        #[doc = " How is this operand accessed? (READ, WRITE or READ|WRITE)"]
        #[doc = " This field is combined of cs_ac_type."]
        #[doc = " NOTE: this field is irrelevant if engine is compiled in DIET"]
        pub access: u8,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_m680x_op__bindgen_ty_1 {
        #[doc = "< immediate value for IMM operand"]
        pub imm: i32,
        #[doc = "< register value for REG operand"]
        pub reg: root::m680x_reg,
        #[doc = "< Indexed addressing operand"]
        pub idx: root::m680x_op_idx,
        #[doc = "< Relative address. operand (Bcc/LBcc)"]
        pub rel: root::m680x_op_rel,
        #[doc = "< Extended address"]
        pub ext: root::m680x_op_ext,
        #[doc = "<</ Direct address (lower 8-bit)"]
        pub direct_addr: u8,
        #[doc = "< constant value (bit index, page nr.)"]
        pub const_val: u8,
    }
    #[doc = " The M680X instruction and it's operands"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_m680x {
        #[doc = "< See: M680X instruction flags"]
        pub flags: u8,
        #[doc = "< number of operands for the instruction or 0"]
        pub op_count: u8,
        #[doc = "< operands for this insn."]
        pub operands: [root::cs_m680x_op; 9usize],
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_evm {
        #[doc = "< number of items popped from the stack"]
        pub pop: cty::c_uchar,
        #[doc = "< number of items pushed into the stack"]
        pub push: cty::c_uchar,
        #[doc = "< gas fee for the instruction"]
        pub fee: cty::c_uint,
    }
    pub const riscv_op_type_RISCV_OP_INVALID: root::riscv_op_type = 0;
    pub const riscv_op_type_RISCV_OP_REG: root::riscv_op_type = 1;
    pub const riscv_op_type_RISCV_OP_IMM: root::riscv_op_type = 2;
    pub const riscv_op_type_RISCV_OP_MEM: root::riscv_op_type = 3;
    pub type riscv_op_type = cty::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct riscv_op_mem {
        pub base: cty::c_uint,
        pub disp: i64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_riscv_op {
        pub type_: root::riscv_op_type,
        pub __bindgen_anon_1: root::cs_riscv_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_riscv_op__bindgen_ty_1 {
        pub reg: cty::c_uint,
        pub imm: i64,
        pub mem: root::riscv_op_mem,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_riscv {
        pub need_effective_addr: bool,
        pub op_count: u8,
        pub operands: [root::cs_riscv_op; 8usize],
    }
    pub const wasm_op_type_WASM_OP_INVALID: root::wasm_op_type = 0;
    pub const wasm_op_type_WASM_OP_NONE: root::wasm_op_type = 1;
    pub const wasm_op_type_WASM_OP_INT7: root::wasm_op_type = 2;
    pub const wasm_op_type_WASM_OP_VARUINT32: root::wasm_op_type = 3;
    pub const wasm_op_type_WASM_OP_VARUINT64: root::wasm_op_type = 4;
    pub const wasm_op_type_WASM_OP_UINT32: root::wasm_op_type = 5;
    pub const wasm_op_type_WASM_OP_UINT64: root::wasm_op_type = 6;
    pub const wasm_op_type_WASM_OP_IMM: root::wasm_op_type = 7;
    pub const wasm_op_type_WASM_OP_BRTABLE: root::wasm_op_type = 8;
    pub type wasm_op_type = cty::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_wasm_brtable {
        pub length: u32,
        pub address: u64,
        pub default_target: u32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_wasm_op {
        pub type_: root::wasm_op_type,
        pub size: u32,
        pub __bindgen_anon_1: root::cs_wasm_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_wasm_op__bindgen_ty_1 {
        pub int7: i8,
        pub varuint32: u32,
        pub varuint64: u64,
        pub uint32: u32,
        pub uint64: u64,
        pub immediate: [u32; 2usize],
        pub brtable: root::cs_wasm_brtable,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_wasm {
        pub op_count: u8,
        pub operands: [root::cs_wasm_op; 2usize],
    }
    pub const mos65xx_reg_MOS65XX_REG_INVALID: root::mos65xx_reg = 0;
    #[doc = "< accumulator"]
    pub const mos65xx_reg_MOS65XX_REG_ACC: root::mos65xx_reg = 1;
    #[doc = "< X index register"]
    pub const mos65xx_reg_MOS65XX_REG_X: root::mos65xx_reg = 2;
    #[doc = "< Y index register"]
    pub const mos65xx_reg_MOS65XX_REG_Y: root::mos65xx_reg = 3;
    #[doc = "< status register"]
    pub const mos65xx_reg_MOS65XX_REG_P: root::mos65xx_reg = 4;
    #[doc = "< stack pointer register"]
    pub const mos65xx_reg_MOS65XX_REG_SP: root::mos65xx_reg = 5;
    #[doc = "< direct page register"]
    pub const mos65xx_reg_MOS65XX_REG_DP: root::mos65xx_reg = 6;
    #[doc = "< data bank register"]
    pub const mos65xx_reg_MOS65XX_REG_B: root::mos65xx_reg = 7;
    #[doc = "< program bank register"]
    pub const mos65xx_reg_MOS65XX_REG_K: root::mos65xx_reg = 8;
    pub const mos65xx_reg_MOS65XX_REG_ENDING: root::mos65xx_reg = 9;
    #[doc = " MOS65XX registers and special registers"]
    pub type mos65xx_reg = cty::c_int;
    #[doc = "< No address mode."]
    pub const mos65xx_address_mode_MOS65XX_AM_NONE: root::mos65xx_address_mode = 0;
    #[doc = "< implied addressing (no addressing mode)"]
    pub const mos65xx_address_mode_MOS65XX_AM_IMP: root::mos65xx_address_mode = 1;
    #[doc = "< accumulator addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ACC: root::mos65xx_address_mode = 2;
    #[doc = "< 8/16 Bit immediate value"]
    pub const mos65xx_address_mode_MOS65XX_AM_IMM: root::mos65xx_address_mode = 3;
    #[doc = "< relative addressing used by branches"]
    pub const mos65xx_address_mode_MOS65XX_AM_REL: root::mos65xx_address_mode = 4;
    #[doc = "< interrupt addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_INT: root::mos65xx_address_mode = 5;
    #[doc = "< memory block addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_BLOCK: root::mos65xx_address_mode = 6;
    #[doc = "< zeropage addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP: root::mos65xx_address_mode = 7;
    #[doc = "< indexed zeropage addressing by the X index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_X: root::mos65xx_address_mode = 8;
    #[doc = "< indexed zeropage addressing by the Y index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_Y: root::mos65xx_address_mode = 9;
    #[doc = "< zero page address, branch relative address"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_REL: root::mos65xx_address_mode = 10;
    #[doc = "< indirect zeropage addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_IND: root::mos65xx_address_mode = 11;
    #[doc = "< indexed zeropage indirect addressing by the X index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_X_IND: root::mos65xx_address_mode = 12;
    #[doc = "< indirect zeropage indexed addressing by the Y index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_IND_Y: root::mos65xx_address_mode = 13;
    #[doc = "< zeropage indirect long addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_IND_LONG: root::mos65xx_address_mode = 14;
    #[doc = "< zeropage indirect long addressing indexed by Y register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ZP_IND_LONG_Y: root::mos65xx_address_mode = 15;
    #[doc = "< absolute addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS: root::mos65xx_address_mode = 16;
    #[doc = "< indexed absolute addressing by the X index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_X: root::mos65xx_address_mode = 17;
    #[doc = "< indexed absolute addressing by the Y index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_Y: root::mos65xx_address_mode = 18;
    #[doc = "< absolute indirect addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_IND: root::mos65xx_address_mode = 19;
    #[doc = "< indexed absolute indirect addressing by the X index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_X_IND: root::mos65xx_address_mode = 20;
    #[doc = "< absolute indirect long addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_IND_LONG: root::mos65xx_address_mode = 21;
    #[doc = "< absolute long address mode"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_LONG: root::mos65xx_address_mode = 22;
    #[doc = "< absolute long address mode, indexed by X register"]
    pub const mos65xx_address_mode_MOS65XX_AM_ABS_LONG_X: root::mos65xx_address_mode = 23;
    #[doc = "< stack relative addressing"]
    pub const mos65xx_address_mode_MOS65XX_AM_SR: root::mos65xx_address_mode = 24;
    #[doc = "< indirect stack relative addressing indexed by the Y index register"]
    pub const mos65xx_address_mode_MOS65XX_AM_SR_IND_Y: root::mos65xx_address_mode = 25;
    #[doc = " MOS65XX Addressing Modes"]
    pub type mos65xx_address_mode = cty::c_int;
    #[doc = "< = CS_OP_INVALID (Uninitialized)."]
    pub const mos65xx_op_type_MOS65XX_OP_INVALID: root::mos65xx_op_type = 0;
    #[doc = "< = CS_OP_REG (Register operand)."]
    pub const mos65xx_op_type_MOS65XX_OP_REG: root::mos65xx_op_type = 1;
    #[doc = "< = CS_OP_IMM (Immediate operand)."]
    pub const mos65xx_op_type_MOS65XX_OP_IMM: root::mos65xx_op_type = 2;
    #[doc = "< = CS_OP_MEM (Memory operand)."]
    pub const mos65xx_op_type_MOS65XX_OP_MEM: root::mos65xx_op_type = 3;
    #[doc = " Operand type for instruction's operands"]
    pub type mos65xx_op_type = cty::c_int;
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_mos65xx_op {
        #[doc = "< operand type"]
        pub type_: root::mos65xx_op_type,
        pub __bindgen_anon_1: root::cs_mos65xx_op__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_mos65xx_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: root::mos65xx_reg,
        #[doc = "< immediate value for IMM operand"]
        pub imm: u16,
        #[doc = "< address for MEM operand"]
        pub mem: u32,
    }
    #[doc = " The MOS65XX address mode and it's operands"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_mos65xx {
        pub am: root::mos65xx_address_mode,
        pub modifies_flags: bool,
        #[doc = " Number of operands of this instruction,"]
        #[doc = " or 0 when instruction has no operand."]
        pub op_count: u8,
        #[doc = "< operands for this instruction."]
        pub operands: [root::cs_mos65xx_op; 3usize],
    }
    pub const bpf_op_type_BPF_OP_INVALID: root::bpf_op_type = 0;
    pub const bpf_op_type_BPF_OP_REG: root::bpf_op_type = 1;
    pub const bpf_op_type_BPF_OP_IMM: root::bpf_op_type = 2;
    pub const bpf_op_type_BPF_OP_OFF: root::bpf_op_type = 3;
    pub const bpf_op_type_BPF_OP_MEM: root::bpf_op_type = 4;
    #[doc = "< M[k] in cBPF"]
    pub const bpf_op_type_BPF_OP_MMEM: root::bpf_op_type = 5;
    #[doc = "< corresponds to cBPF's BPF_MSH mode"]
    pub const bpf_op_type_BPF_OP_MSH: root::bpf_op_type = 6;
    #[doc = "< cBPF's extension (not eBPF)"]
    pub const bpf_op_type_BPF_OP_EXT: root::bpf_op_type = 7;
    #[doc = " Operand type for instruction's operands"]
    pub type bpf_op_type = cty::c_int;
    pub const bpf_reg_BPF_REG_INVALID: root::bpf_reg = 0;
    pub const bpf_reg_BPF_REG_A: root::bpf_reg = 1;
    pub const bpf_reg_BPF_REG_X: root::bpf_reg = 2;
    pub const bpf_reg_BPF_REG_R0: root::bpf_reg = 3;
    pub const bpf_reg_BPF_REG_R1: root::bpf_reg = 4;
    pub const bpf_reg_BPF_REG_R2: root::bpf_reg = 5;
    pub const bpf_reg_BPF_REG_R3: root::bpf_reg = 6;
    pub const bpf_reg_BPF_REG_R4: root::bpf_reg = 7;
    pub const bpf_reg_BPF_REG_R5: root::bpf_reg = 8;
    pub const bpf_reg_BPF_REG_R6: root::bpf_reg = 9;
    pub const bpf_reg_BPF_REG_R7: root::bpf_reg = 10;
    pub const bpf_reg_BPF_REG_R8: root::bpf_reg = 11;
    pub const bpf_reg_BPF_REG_R9: root::bpf_reg = 12;
    pub const bpf_reg_BPF_REG_R10: root::bpf_reg = 13;
    pub const bpf_reg_BPF_REG_ENDING: root::bpf_reg = 14;
    #[doc = " BPF registers"]
    pub type bpf_reg = cty::c_int;
    #[doc = " Instruction's operand referring to memory"]
    #[doc = " This is associated with BPF_OP_MEM operand type above"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_op_mem {
        #[doc = "< base register"]
        pub base: root::bpf_reg,
        #[doc = "< offset value"]
        pub disp: u32,
    }
    #[doc = " Instruction operand"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_bpf_op {
        pub type_: root::bpf_op_type,
        pub __bindgen_anon_1: root::cs_bpf_op__bindgen_ty_1,
        #[doc = " How is this operand accessed? (READ, WRITE or READ|WRITE)"]
        #[doc = " This field is combined of cs_ac_type."]
        #[doc = " NOTE: this field is irrelevant if engine is compiled in DIET mode."]
        pub access: u8,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_bpf_op__bindgen_ty_1 {
        #[doc = "< register value for REG operand"]
        pub reg: u8,
        #[doc = "< immediate value IMM operand"]
        pub imm: u64,
        #[doc = "< offset value, used in jump & call"]
        pub off: u32,
        #[doc = "< base/disp value for MEM operand"]
        pub mem: root::bpf_op_mem,
        #[doc = "< M[k] in cBPF"]
        pub mmem: u32,
        #[doc = "< corresponds to cBPF's BPF_MSH mode"]
        pub msh: u32,
        #[doc = "< cBPF's extension (not eBPF)"]
        pub ext: u32,
    }
    #[doc = " Instruction structure"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_bpf {
        pub op_count: u8,
        pub operands: [root::cs_bpf_op; 4usize],
    }
    #[doc = " NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON"]
    #[doc = " Initialized as memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))"]
    #[doc = " by ARCH_getInstruction in arch/ARCH/ARCHDisassembler.c"]
    #[doc = " if cs_detail changes, in particular if a field is added after the union,"]
    #[doc = " then update arch/ARCH/ARCHDisassembler.c accordingly"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cs_detail {
        #[doc = "< list of implicit registers read by this insn"]
        pub regs_read: [u16; 16usize],
        #[doc = "< number of implicit registers read by this insn"]
        pub regs_read_count: u8,
        #[doc = "< list of implicit registers modified by this insn"]
        pub regs_write: [u16; 20usize],
        #[doc = "< number of implicit registers modified by this insn"]
        pub regs_write_count: u8,
        #[doc = "< list of group this instruction belong to"]
        pub groups: [u8; 8usize],
        #[doc = "< number of groups this insn belongs to"]
        pub groups_count: u8,
        pub __bindgen_anon_1: root::cs_detail__bindgen_ty_1,
    }
    #[doc = " Architecture-specific instruction info"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cs_detail__bindgen_ty_1 {
        #[doc = "< X86 architecture, including 16-bit, 32-bit & 64-bit mode"]
        pub x86: root::cs_x86,
        #[doc = "< ARM64 architecture (aka AArch64)"]
        pub arm64: root::cs_arm64,
        #[doc = "< ARM architecture (including Thumb/Thumb2)"]
        pub arm: root::cs_arm,
        #[doc = "< M68K architecture"]
        pub m68k: root::cs_m68k,
        #[doc = "< MIPS architecture"]
        pub mips: root::cs_mips,
        #[doc = "< PowerPC architecture"]
        pub ppc: root::cs_ppc,
        #[doc = "< Sparc architecture"]
        pub sparc: root::cs_sparc,
        #[doc = "< SystemZ architecture"]
        pub sysz: root::cs_sysz,
        #[doc = "< XCore architecture"]
        pub xcore: root::cs_xcore,
        #[doc = "< TMS320C64x architecture"]
        pub tms320c64x: root::cs_tms320c64x,
        #[doc = "< M680X architecture"]
        pub m680x: root::cs_m680x,
        #[doc = "< Ethereum architecture"]
        pub evm: root::cs_evm,
        #[doc = "< MOS65XX architecture (including MOS6502)"]
        pub mos65xx: root::cs_mos65xx,
        #[doc = "< Web Assembly architecture"]
        pub wasm: root::cs_wasm,
        #[doc = "< Berkeley Packet Filter architecture (including eBPF)"]
        pub bpf: root::cs_bpf,
        #[doc = "< RISCV architecture"]
        pub riscv: root::cs_riscv,
    }
    #[doc = " Detail information of disassembled instruction"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cs_insn {
        #[doc = " Instruction ID (basically a numeric ID for the instruction mnemonic)"]
        #[doc = " Find the instruction id in the '[ARCH]_insn' enum in the header file"]
        #[doc = " of corresponding architecture, such as 'arm_insn' in arm.h for ARM,"]
        #[doc = " 'x86_insn' in x86.h for X86, etc..."]
        #[doc = " This information is available even when CS_OPT_DETAIL = CS_OPT_OFF"]
        #[doc = " NOTE: in Skipdata mode, \"data\" instruction has 0 for this id field."]
        pub id: cty::c_uint,
        #[doc = " Address (EIP) of this instruction"]
        #[doc = " This information is available even when CS_OPT_DETAIL = CS_OPT_OFF"]
        pub address: u64,
        #[doc = " Size of this instruction"]
        #[doc = " This information is available even when CS_OPT_DETAIL = CS_OPT_OFF"]
        pub size: u16,
        #[doc = " Machine bytes of this instruction, with number of bytes indicated by @size above"]
        #[doc = " This information is available even when CS_OPT_DETAIL = CS_OPT_OFF"]
        pub bytes: [u8; 24usize],
        #[doc = " Ascii text of instruction mnemonic"]
        #[doc = " This information is available even when CS_OPT_DETAIL = CS_OPT_OFF"]
        pub mnemonic: [cty::c_char; 32usize],
        #[doc = " Ascii text of instruction operands"]
        #[doc = " This information is available even when CS_OPT_DETAIL = CS_OPT_OFF"]
        pub op_str: [cty::c_char; 160usize],
        #[doc = " Pointer to cs_detail."]
        #[doc = " NOTE: detail pointer is only valid when both requirements below are met:"]
        #[doc = " (1) CS_OP_DETAIL = CS_OPT_ON"]
        #[doc = " (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)"]
        #[doc = ""]
        #[doc = " NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer"]
        #[doc = "     is not NULL, its content is still irrelevant."]
        pub detail: *mut root::cs_detail,
    }
    pub mod PLH {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const HookType_Detour: root::PLH::HookType = 0;
        pub const HookType_VEHHOOK: root::PLH::HookType = 1;
        pub const HookType_VTableSwap: root::PLH::HookType = 2;
        pub const HookType_IAT: root::PLH::HookType = 3;
        pub const HookType_EAT: root::PLH::HookType = 4;
        pub const HookType_UNKNOWN: root::PLH::HookType = 5;
        pub type HookType = cty::c_int;
        pub const ProtFlag_UNSET: root::PLH::ProtFlag = 0;
        pub const ProtFlag_X: root::PLH::ProtFlag = 2;
        pub const ProtFlag_R: root::PLH::ProtFlag = 4;
        pub const ProtFlag_W: root::PLH::ProtFlag = 8;
        pub const ProtFlag_S: root::PLH::ProtFlag = 16;
        pub const ProtFlag_P: root::PLH::ProtFlag = 32;
        pub const ProtFlag_NONE: root::PLH::ProtFlag = 64;
        pub type ProtFlag = cty::c_uchar;
        pub const JmpType_Absolute: root::PLH::JmpType = 0;
        pub const JmpType_Indirect: root::PLH::JmpType = 1;
        pub type JmpType = cty::c_int;
        pub const Mode_x86: root::PLH::Mode = 0;
        pub const Mode_x64: root::PLH::Mode = 1;
        pub type Mode = cty::c_int;
        pub const ErrorLevel_INFO: root::PLH::ErrorLevel = 0;
        pub const ErrorLevel_WARN: root::PLH::ErrorLevel = 1;
        pub const ErrorLevel_SEV: root::PLH::ErrorLevel = 2;
        pub const ErrorLevel_NONE: root::PLH::ErrorLevel = 3;
        pub type ErrorLevel = cty::c_int;
        #[repr(C)]
        pub struct Logger__bindgen_vtable(cty::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct Logger {
            pub vtable_: *const Logger__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Log {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}?m_logger@Log@PLH@@0V?$shared_ptr@VLogger@PLH@@@std@@A"]
            pub static mut Log_m_logger: u8;
        }
        extern "C" {
            #[link_name = "\u{1}?registerLogger@Log@PLH@@SAXV?$shared_ptr@VLogger@PLH@@@std@@@Z"]
            pub fn Log_registerLogger(logger: u8);
        }
        extern "C" {
            #[link_name = "\u{1}?log@Log@PLH@@SAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4ErrorLevel@2@@Z"]
            pub fn Log_log(msg: root::std::string, level: root::PLH::ErrorLevel);
        }
        impl Log {
            #[inline]
            pub unsafe fn registerLogger(logger: u8) {
                Log_registerLogger(logger)
            }
            #[inline]
            pub unsafe fn log(msg: root::std::string, level: root::PLH::ErrorLevel) {
                Log_log(msg, level)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Error {
            pub msg: root::std::string,
            pub lvl: root::PLH::ErrorLevel,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ErrorLog {
            pub _base: root::PLH::Logger,
            pub m_log: [u64; 3usize],
            pub m_logLevel: root::PLH::ErrorLevel,
        }
        extern "C" {
            #[link_name = "\u{1}?setLogLevel@ErrorLog@PLH@@QEAAXW4ErrorLevel@2@@Z"]
            pub fn ErrorLog_setLogLevel(
                this: *mut root::PLH::ErrorLog,
                level: root::PLH::ErrorLevel,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?push@ErrorLog@PLH@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4ErrorLevel@2@@Z"]
            pub fn ErrorLog_push(
                this: *mut root::PLH::ErrorLog,
                msg: root::std::string,
                level: root::PLH::ErrorLevel,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?push@ErrorLog@PLH@@QEAAXUError@2@@Z"]
            pub fn ErrorLog_push1(this: *mut root::PLH::ErrorLog, err: root::PLH::Error);
        }
        extern "C" {
            #[link_name = "\u{1}?pop@ErrorLog@PLH@@QEAA?AUError@2@XZ"]
            pub fn ErrorLog_pop(this: *mut root::PLH::ErrorLog) -> root::PLH::Error;
        }
        extern "C" {
            #[link_name = "\u{1}?singleton@ErrorLog@PLH@@SAAEAV12@XZ"]
            pub fn ErrorLog_singleton() -> *mut root::PLH::ErrorLog;
        }
        impl ErrorLog {
            #[inline]
            pub unsafe fn setLogLevel(&mut self, level: root::PLH::ErrorLevel) {
                ErrorLog_setLogLevel(self, level)
            }
            #[inline]
            pub unsafe fn push(&mut self, msg: root::std::string, level: root::PLH::ErrorLevel) {
                ErrorLog_push(self, msg, level)
            }
            #[inline]
            pub unsafe fn push1(&mut self, err: root::PLH::Error) {
                ErrorLog_push1(self, err)
            }
            #[inline]
            pub unsafe fn pop(&mut self) -> root::PLH::Error {
                ErrorLog_pop(self)
            }
            #[inline]
            pub unsafe fn singleton() -> *mut root::PLH::ErrorLog {
                ErrorLog_singleton()
            }
        }
        extern "C" {
            #[link_name = "\u{1}?log@ErrorLog@PLH@@UEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4ErrorLevel@2@@Z"]
            pub fn ErrorLog_log(
                this: *mut cty::c_void,
                msg: root::std::string,
                level: root::PLH::ErrorLevel,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UID {
            pub val: cty::c_long,
        }
        extern "C" {
            #[link_name = "\u{1}?singleton@UID@PLH@@SAAEAU?$atomic@J@std@@XZ"]
            pub fn UID_singleton() -> *mut root::std::atomic_long;
        }
        extern "C" {
            #[link_name = "\u{1}??0UID@PLH@@QEAA@J@Z"]
            pub fn UID_UID(this: *mut root::PLH::UID, val: cty::c_long);
        }
        impl UID {
            #[inline]
            pub unsafe fn singleton() -> *mut root::std::atomic_long {
                UID_singleton()
            }
            #[inline]
            pub unsafe fn new(val: cty::c_long) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                UID_UID(__bindgen_tmp.as_mut_ptr(), val);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct Instruction {
            pub m_isRelative: bool,
            pub m_hasDisplacement: bool,
            pub m_isBranching: bool,
            pub m_isIndirect: bool,
            pub m_isCalling: bool,
            pub m_address: u64,
            pub m_displacement: root::PLH::Instruction_Displacement,
            pub m_dispOffset: u8,
            pub m_bytes: [u64; 3usize],
            pub m_mnemonic: root::std::string,
            pub m_opStr: root::std::string,
            pub m_mode: root::PLH::Mode,
            pub m_uid: root::PLH::UID,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union Instruction_Displacement {
            pub Relative: i64,
            pub Absolute: u64,
        }
        pub type insts_t = [u64; 3usize];
        #[repr(C)]
        pub struct MemAccessor__bindgen_vtable(cty::c_void);
        #[doc = "Overriding these routines can allow cross-process/cross-arch hooks"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct MemAccessor {
            pub vtable_: *const MemAccessor__bindgen_vtable,
        }
        extern "C" {
            #[doc = "Defines a memory read/write routine that may fail ungracefully. It's expected"]
            #[doc = "this library will only ever use this routine in cases that are expected to succeed."]
            #[link_name = "\u{1}?mem_copy@MemAccessor@PLH@@UEBA_N_K00@Z"]
            pub fn MemAccessor_mem_copy(
                this: *mut cty::c_void,
                dest: u64,
                src: u64,
                size: u64,
            ) -> bool;
        }
        extern "C" {
            #[doc = "Defines a memory write routine that will not throw exceptions, and can handle potential"]
            #[doc = "writes to NO_ACCESS or otherwise innaccessible memory pages. Defaults to writeprocessmemory."]
            #[doc = "Must fail gracefully"]
            #[link_name = "\u{1}?safe_mem_write@MemAccessor@PLH@@UEBA_N_K00AEA_K@Z"]
            pub fn MemAccessor_safe_mem_write(
                this: *mut cty::c_void,
                dest: u64,
                src: u64,
                size: u64,
                written: *mut usize,
            ) -> bool;
        }
        extern "C" {
            #[doc = "Defines a memory read routine that will not throw exceptions, and can handle potential"]
            #[doc = "reads from NO_ACCESS or otherwise innaccessible memory pages. Defaults to readprocessmemory."]
            #[doc = "Must fail gracefully"]
            #[link_name = "\u{1}?safe_mem_read@MemAccessor@PLH@@UEBA_N_K00AEA_K@Z"]
            pub fn MemAccessor_safe_mem_read(
                this: *mut cty::c_void,
                src: u64,
                dest: u64,
                size: u64,
                read: *mut usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?mem_protect@MemAccessor@PLH@@UEBA?AW4ProtFlag@2@_K0W432@AEA_N@Z"]
            pub fn MemAccessor_mem_protect(
                this: *mut cty::c_void,
                dest: u64,
                size: u64,
                newProtection: root::PLH::ProtFlag,
                status: *mut bool,
            ) -> root::PLH::ProtFlag;
        }
        pub type branch_map_t = [u64; 8usize];
        #[repr(C)]
        pub struct ADisassembler__bindgen_vtable(cty::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ADisassembler {
            pub vtable_: *const ADisassembler__bindgen_vtable,
            pub m_mode: root::PLH::Mode,
            pub m_branchMap: root::PLH::branch_map_t,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct CapstoneDisassembler {
            pub _base: root::PLH::ADisassembler,
            pub m_capHandle: root::csh,
        }
        extern "C" {
            #[link_name = "\u{1}??0CapstoneDisassembler@PLH@@QEAA@W4Mode@1@@Z"]
            pub fn CapstoneDisassembler_CapstoneDisassembler(
                this: *mut root::PLH::CapstoneDisassembler,
                mode: root::PLH::Mode,
            );
        }
        impl CapstoneDisassembler {
            #[inline]
            pub unsafe fn new(mode: root::PLH::Mode) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                CapstoneDisassembler_CapstoneDisassembler(__bindgen_tmp.as_mut_ptr(), mode);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DCapstoneDisassembler@PLH@@QEAAXXZ"]
            pub fn CapstoneDisassembler_CapstoneDisassembler_destructor(
                this: *mut root::PLH::CapstoneDisassembler,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?disassemble@CapstoneDisassembler@PLH@@UEAA?AV?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@std@@_K00AEBVMemAccessor@2@@Z"]
            pub fn CapstoneDisassembler_disassemble(
                this: *mut cty::c_void,
                firstInstruction: u64,
                start: u64,
                end: u64,
                accessor: *const root::PLH::MemAccessor,
            ) -> [u64; 3usize];
        }
        extern "C" {
            #[link_name = "\u{1}?TranslateProtection@PLH@@YAHW4ProtFlag@1@@Z"]
            pub fn TranslateProtection(flags: root::PLH::ProtFlag) -> cty::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?TranslateProtection@PLH@@YA?AW4ProtFlag@1@H@Z"]
            pub fn TranslateProtection1(prot: cty::c_int) -> root::PLH::ProtFlag;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct MemoryProtector {
            pub m_origProtection: root::PLH::ProtFlag,
            pub m_accessor: *mut root::PLH::MemAccessor,
            pub m_address: u64,
            pub m_length: u64,
            pub status: bool,
            pub unsetLater: bool,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IHook {
            pub _base: root::PLH::MemAccessor,
            pub m_debugSet: bool,
            pub m_hooked: bool,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct callback_type {
            pub _address: u8,
        }
        pub type callback_type_type<T> = T;
        pub type callback_type_t = root::PLH::callback_type;
        pub type callback_type_v = root::PLH::callback_type;
        pub const Platform_WIN: root::PLH::Platform = 0;
        pub const Platform_UNIX: root::PLH::Platform = 1;
        pub type Platform = cty::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotImplementedException {
            pub _base: root::std::logic_error,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ValueNotSetException {
            pub _base: root::std::logic_error,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocationFailure {
            pub _base: root::std::logic_error,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FinalAction<Func> {
            pub FinalActionFunc: Func,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<Func>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ci_wchar_traits {
            pub _base: u8,
        }
        extern "C" {
            #[link_name = "\u{1}?findPattern@PLH@@YA_K_K_KPEBD@Z"]
            pub fn findPattern(rangeStart: u64, len: usize, pattern: *const cty::c_char) -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}?findPattern_rev@PLH@@YA_K_K_KPEBD@Z"]
            pub fn findPattern_rev(rangeStart: u64, len: usize, pattern: *const cty::c_char)
                -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}?getPatternSize@PLH@@YA_KPEBD@Z"]
            pub fn getPatternSize(pattern: *const cty::c_char) -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}?boundedAllocSupported@PLH@@YA_NXZ"]
            pub fn boundedAllocSupported() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?boundAlloc@PLH@@YA_K_K00@Z"]
            pub fn boundAlloc(min: u64, max: u64, size: u64) -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}?boundAllocLegacy@PLH@@YA_K_K00@Z"]
            pub fn boundAllocLegacy(min: u64, max: u64, size: u64) -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}?boundAllocFree@PLH@@YAX_K0@Z"]
            pub fn boundAllocFree(address: u64, size: u64);
        }
        extern "C" {
            #[link_name = "\u{1}?getAllocationAlignment@PLH@@YA_KXZ"]
            pub fn getAllocationAlignment() -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?getPageSize@PLH@@YA_KXZ"]
            pub fn getPageSize() -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?calc_2gb_below@PLH@@YA_K_K@Z"]
            pub fn calc_2gb_below(address: u64) -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}?calc_2gb_above@PLH@@YA_K_K@Z"]
            pub fn calc_2gb_above(address: u64) -> u64;
        }
        pub type ci_wstring = u8;
        pub type ci_wstring_view = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct Detour {
            pub _base: root::PLH::IHook,
            pub m_fnAddress: u64,
            pub m_fnCallback: u64,
            pub m_trampoline: u64,
            pub m_trampolineSz: u16,
            pub m_userTrampVar: *mut u64,
            pub m_disasm: *mut root::PLH::ADisassembler,
            pub m_maxDepth: u8,
            pub m_originalInsts: root::PLH::insts_t,
            pub m_hookInsts: root::PLH::insts_t,
            pub m_nopProlOffset: u16,
            pub m_nopSize: u16,
            pub m_hookSize: u32,
        }
        pub const Detour_c_maxDepth: u8 = 5;
        extern "C" {
            #[doc = "Walks the given vector of instructions and sets roundedSz to the lowest size possible that doesn't split any instructions and is greater than minSz."]
            #[doc = "If end of function is encountered before this condition an empty optional is returned. Returns instructions in the range start to adjusted end"]
            #[link_name = "\u{1}?calcNearestSz@Detour@PLH@@IEAA?AV?$optional@V?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@std@@@std@@AEBV?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@4@_KAEA_K@Z"]
            pub fn Detour_calcNearestSz(
                this: *mut root::PLH::Detour,
                functionInsts: *const root::PLH::insts_t,
                minSz: u64,
                roundedSz: *mut u64,
            ) -> u8;
        }
        extern "C" {
            #[doc = "If function starts with a jump follow it until the first non-jump instruction, recursively. This handles already hooked functions"]
            #[doc = "and also compilers that emit jump tables on function call. Returns true if resolution was successful (nothing to resolve, or resolution worked),"]
            #[doc = "false if resolution failed."]
            #[link_name = "\u{1}?followJmp@Detour@PLH@@IEAA_NAEAV?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@std@@EE@Z"]
            pub fn Detour_followJmp(
                this: *mut root::PLH::Detour,
                functionInsts: *mut root::PLH::insts_t,
                curDepth: u8,
                maxDepth: u8,
            ) -> bool;
        }
        extern "C" {
            #[doc = "Expand the prologue up to the address of the last jmp that points back into the prologue. This"]
            #[doc = "is necessary because we modify the location of things in the prologue, so re-entrant jmps point"]
            #[doc = "to the wrong place. Therefore we move all of it to the trampoline where there is ample space to"]
            #[doc = "relocate and create jmp tbl entries"]
            #[link_name = "\u{1}?expandProlSelfJmps@Detour@PLH@@IEAA_NAEAV?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@std@@AEBV34@AEA_K2@Z"]
            pub fn Detour_expandProlSelfJmps(
                this: *mut root::PLH::Detour,
                prol: *mut root::PLH::insts_t,
                func: *const root::PLH::insts_t,
                minProlSz: *mut u64,
                roundProlSz: *mut u64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?buildRelocationList@Detour@PLH@@IEAA_NAEAV?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@std@@_K_J00@Z"]
            pub fn Detour_buildRelocationList(
                this: *mut root::PLH::Detour,
                prologue: *mut root::PLH::insts_t,
                roundProlSz: u64,
                delta: i64,
                instsNeedingEntry: *mut root::PLH::insts_t,
                instsNeedingReloc: *mut root::PLH::insts_t,
            ) -> bool;
        }
        extern "C" {
            #[doc = "Insert nops from [Base, Base+size). We _MUST_ insert multi-byte nops so we don't accidentally"]
            #[doc = "confused our code cave finder for x64"]
            #[link_name = "\u{1}?writeNop@Detour@PLH@@IEAAX_KI@Z"]
            pub fn Detour_writeNop(this: *mut root::PLH::Detour, base: u64, size: u32);
        }
        impl Detour {
            #[inline]
            pub unsafe fn calcNearestSz(
                &mut self,
                functionInsts: *const root::PLH::insts_t,
                minSz: u64,
                roundedSz: *mut u64,
            ) -> u8 {
                Detour_calcNearestSz(self, functionInsts, minSz, roundedSz)
            }
            #[inline]
            pub unsafe fn followJmp(
                &mut self,
                functionInsts: *mut root::PLH::insts_t,
                curDepth: u8,
                maxDepth: u8,
            ) -> bool {
                Detour_followJmp(self, functionInsts, curDepth, maxDepth)
            }
            #[inline]
            pub unsafe fn expandProlSelfJmps(
                &mut self,
                prol: *mut root::PLH::insts_t,
                func: *const root::PLH::insts_t,
                minProlSz: *mut u64,
                roundProlSz: *mut u64,
            ) -> bool {
                Detour_expandProlSelfJmps(self, prol, func, minProlSz, roundProlSz)
            }
            #[inline]
            pub unsafe fn buildRelocationList(
                &mut self,
                prologue: *mut root::PLH::insts_t,
                roundProlSz: u64,
                delta: i64,
                instsNeedingEntry: *mut root::PLH::insts_t,
                instsNeedingReloc: *mut root::PLH::insts_t,
            ) -> bool {
                Detour_buildRelocationList(
                    self,
                    prologue,
                    roundProlSz,
                    delta,
                    instsNeedingEntry,
                    instsNeedingReloc,
                )
            }
            #[inline]
            pub unsafe fn writeNop(&mut self, base: u64, size: u32) {
                Detour_writeNop(self, base, size)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?unHook@Detour@PLH@@UEAA_NXZ"]
            pub fn Detour_unHook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[doc = "This is for restoring hook bytes if a 3rd party uninstalled them."]
            #[doc = "DO NOT call this after unHook(). This may only be called after hook()"]
            #[doc = "but before unHook()"]
            #[link_name = "\u{1}?reHook@Detour@PLH@@UEAA_NXZ"]
            pub fn Detour_reHook(this: *mut cty::c_void) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FBAllocator {
            pub m_alloc2Supported: bool,
            pub m_usedBlocks: u8,
            pub m_maxBlocks: u8,
            pub m_blockSize: u8,
            pub m_min: u64,
            pub m_max: u64,
            pub m_dataPool: u64,
            pub m_allocator: *mut root::ALLOC_Allocator,
            pub m_hAllocator: root::ALLOC_HANDLE,
        }
        extern "C" {
            #[link_name = "\u{1}?initialize@FBAllocator@PLH@@QEAA_NXZ"]
            pub fn FBAllocator_initialize(this: *mut root::PLH::FBAllocator) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?allocate@FBAllocator@PLH@@QEAAPEADXZ"]
            pub fn FBAllocator_allocate(this: *mut root::PLH::FBAllocator) -> *mut cty::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?callocate@FBAllocator@PLH@@QEAAPEADE@Z"]
            pub fn FBAllocator_callocate(
                this: *mut root::PLH::FBAllocator,
                num: u8,
            ) -> *mut cty::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@FBAllocator@PLH@@QEAAXPEAD@Z"]
            pub fn FBAllocator_deallocate(this: *mut root::PLH::FBAllocator, mem: *mut cty::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}?inRange@FBAllocator@PLH@@QEAA_N_K@Z"]
            pub fn FBAllocator_inRange(this: *mut root::PLH::FBAllocator, addr: u64) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?intersectsRange@FBAllocator@PLH@@QEAA_N_K0@Z"]
            pub fn FBAllocator_intersectsRange(
                this: *mut root::PLH::FBAllocator,
                min: u64,
                max: u64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?intersectionLoadFactor@FBAllocator@PLH@@QEAAE_K0@Z"]
            pub fn FBAllocator_intersectionLoadFactor(
                this: *mut root::PLH::FBAllocator,
                min: u64,
                max: u64,
            ) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}??0FBAllocator@PLH@@QEAA@_K0EE@Z"]
            pub fn FBAllocator_FBAllocator(
                this: *mut root::PLH::FBAllocator,
                min: u64,
                max: u64,
                blockSize: u8,
                blockCount: u8,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DFBAllocator@PLH@@QEAAXXZ"]
            pub fn FBAllocator_FBAllocator_destructor(this: *mut root::PLH::FBAllocator);
        }
        impl FBAllocator {
            #[inline]
            pub unsafe fn initialize(&mut self) -> bool {
                FBAllocator_initialize(self)
            }
            #[inline]
            pub unsafe fn allocate(&mut self) -> *mut cty::c_char {
                FBAllocator_allocate(self)
            }
            #[inline]
            pub unsafe fn callocate(&mut self, num: u8) -> *mut cty::c_char {
                FBAllocator_callocate(self, num)
            }
            #[inline]
            pub unsafe fn deallocate(&mut self, mem: *mut cty::c_char) {
                FBAllocator_deallocate(self, mem)
            }
            #[inline]
            pub unsafe fn inRange(&mut self, addr: u64) -> bool {
                FBAllocator_inRange(self, addr)
            }
            #[inline]
            pub unsafe fn intersectsRange(&mut self, min: u64, max: u64) -> bool {
                FBAllocator_intersectsRange(self, min, max)
            }
            #[inline]
            pub unsafe fn intersectionLoadFactor(&mut self, min: u64, max: u64) -> u8 {
                FBAllocator_intersectionLoadFactor(self, min, max)
            }
            #[inline]
            pub unsafe fn new(min: u64, max: u64, blockSize: u8, blockCount: u8) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                FBAllocator_FBAllocator(
                    __bindgen_tmp.as_mut_ptr(),
                    min,
                    max,
                    blockSize,
                    blockCount,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                FBAllocator_FBAllocator_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RangeAllocator {
            pub m_maxBlocks: u8,
            pub m_blockSize: u8,
            pub m_mutex: root::std::mutex,
            pub m_allocators: [u64; 3usize],
            pub m_allocMap: [u64; 8usize],
        }
        extern "C" {
            #[link_name = "\u{1}?allocate@RangeAllocator@PLH@@QEAAPEAD_K0@Z"]
            pub fn RangeAllocator_allocate(
                this: *mut root::PLH::RangeAllocator,
                min: u64,
                max: u64,
            ) -> *mut cty::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@RangeAllocator@PLH@@QEAAX_K@Z"]
            pub fn RangeAllocator_deallocate(this: *mut root::PLH::RangeAllocator, addr: u64);
        }
        extern "C" {
            #[link_name = "\u{1}??0RangeAllocator@PLH@@QEAA@EE@Z"]
            pub fn RangeAllocator_RangeAllocator(
                this: *mut root::PLH::RangeAllocator,
                blockSize: u8,
                blockCount: u8,
            );
        }
        impl RangeAllocator {
            #[inline]
            pub unsafe fn allocate(&mut self, min: u64, max: u64) -> *mut cty::c_char {
                RangeAllocator_allocate(self, min, max)
            }
            #[inline]
            pub unsafe fn deallocate(&mut self, addr: u64) {
                RangeAllocator_deallocate(self, addr)
            }
            #[inline]
            pub unsafe fn new(blockSize: u8, blockCount: u8) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                RangeAllocator_RangeAllocator(__bindgen_tmp.as_mut_ptr(), blockSize, blockCount);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct x64Detour {
            pub _base: root::PLH::Detour,
            pub _detourScheme: root::PLH::x64Detour_detour_scheme_t,
            pub m_valloc2_region: [u64; 2usize],
            pub m_allocator: root::PLH::RangeAllocator,
        }
        pub const x64Detour_detour_scheme_t_CODE_CAVE: root::PLH::x64Detour_detour_scheme_t = 1;
        pub const x64Detour_detour_scheme_t_INPLACE: root::PLH::x64Detour_detour_scheme_t = 2;
        pub const x64Detour_detour_scheme_t_VALLOC2: root::PLH::x64Detour_detour_scheme_t = 4;
        pub const x64Detour_detour_scheme_t_RECOMMENDED: root::PLH::x64Detour_detour_scheme_t = 5;
        pub const x64Detour_detour_scheme_t_ALL: root::PLH::x64Detour_detour_scheme_t = 7;
        pub type x64Detour_detour_scheme_t = u8;
        extern "C" {
            #[link_name = "\u{1}?getMinJmpSize@x64Detour@PLH@@QEBAEXZ"]
            pub fn x64Detour_getMinJmpSize(this: *const root::PLH::x64Detour) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}?getPrefJmpSize@x64Detour@PLH@@QEBAEXZ"]
            pub fn x64Detour_getPrefJmpSize(this: *const root::PLH::x64Detour) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}?getDetourScheme@x64Detour@PLH@@QEBA?AW4detour_scheme_t@12@XZ"]
            pub fn x64Detour_getDetourScheme(
                this: *const root::PLH::x64Detour,
            ) -> root::PLH::x64Detour_detour_scheme_t;
        }
        extern "C" {
            #[link_name = "\u{1}?setDetourScheme@x64Detour@PLH@@QEAAXW4detour_scheme_t@12@@Z"]
            pub fn x64Detour_setDetourScheme(
                this: *mut root::PLH::x64Detour,
                scheme: root::PLH::x64Detour_detour_scheme_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?makeTrampoline@x64Detour@PLH@@IEAA_NAEAV?$vector@VInstruction@PLH@@V?$allocator@VInstruction@PLH@@@std@@@std@@0@Z"]
            pub fn x64Detour_makeTrampoline(
                this: *mut root::PLH::x64Detour,
                prologue: *mut root::PLH::insts_t,
                trampolineOut: *mut root::PLH::insts_t,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0x64Detour@PLH@@QEAA@_K0PEA_KAEAVADisassembler@1@E@Z"]
            pub fn x64Detour_x64Detour(
                this: *mut root::PLH::x64Detour,
                fnAddress: u64,
                fnCallback: u64,
                userTrampVar: *mut u64,
                dis: *mut root::PLH::ADisassembler,
                maxDepth: u8,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0x64Detour@PLH@@QEAA@PEBD0PEA_KAEAVADisassembler@1@E@Z"]
            pub fn x64Detour_x64Detour1(
                this: *mut root::PLH::x64Detour,
                fnAddress: *const cty::c_char,
                fnCallback: *const cty::c_char,
                userTrampVar: *mut u64,
                dis: *mut root::PLH::ADisassembler,
                maxDepth: u8,
            );
        }
        impl x64Detour {
            #[inline]
            pub unsafe fn getMinJmpSize(&self) -> u8 {
                x64Detour_getMinJmpSize(self)
            }
            #[inline]
            pub unsafe fn getPrefJmpSize(&self) -> u8 {
                x64Detour_getPrefJmpSize(self)
            }
            #[inline]
            pub unsafe fn getDetourScheme(&self) -> root::PLH::x64Detour_detour_scheme_t {
                x64Detour_getDetourScheme(self)
            }
            #[inline]
            pub unsafe fn setDetourScheme(&mut self, scheme: root::PLH::x64Detour_detour_scheme_t) {
                x64Detour_setDetourScheme(self, scheme)
            }
            #[inline]
            pub unsafe fn makeTrampoline(
                &mut self,
                prologue: *mut root::PLH::insts_t,
                trampolineOut: *mut root::PLH::insts_t,
            ) -> bool {
                x64Detour_makeTrampoline(self, prologue, trampolineOut)
            }
            #[inline]
            pub unsafe fn new(
                fnAddress: u64,
                fnCallback: u64,
                userTrampVar: *mut u64,
                dis: *mut root::PLH::ADisassembler,
                maxDepth: u8,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                x64Detour_x64Detour(
                    __bindgen_tmp.as_mut_ptr(),
                    fnAddress,
                    fnCallback,
                    userTrampVar,
                    dis,
                    maxDepth,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                fnAddress: *const cty::c_char,
                fnCallback: *const cty::c_char,
                userTrampVar: *mut u64,
                dis: *mut root::PLH::ADisassembler,
                maxDepth: u8,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                x64Detour_x64Detour1(
                    __bindgen_tmp.as_mut_ptr(),
                    fnAddress,
                    fnCallback,
                    userTrampVar,
                    dis,
                    maxDepth,
                );
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_Dx64Detour@PLH@@QEAAXXZ"]
            pub fn x64Detour_x64Detour_destructor(this: *mut root::PLH::x64Detour);
        }
        extern "C" {
            #[link_name = "\u{1}?hook@x64Detour@PLH@@UEAA_NXZ"]
            pub fn x64Detour_hook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unHook@x64Detour@PLH@@UEAA_NXZ"]
            pub fn x64Detour_unHook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?getArchType@x64Detour@PLH@@UEBA?AW4Mode@2@XZ"]
            pub fn x64Detour_getArchType(this: *mut cty::c_void) -> root::PLH::Mode;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EventDispatcher {
            pub m_Event: root::PLH::EventDispatcher_Event,
        }
        pub type EventDispatcher_Event = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RefCounter {
            pub m_count: u16,
        }
        pub const AVehHookImpType_SINGLE: root::PLH::AVehHookImpType = 0;
        pub const AVehHookImpType_RANGE: root::PLH::AVehHookImpType = 1;
        pub type AVehHookImpType = cty::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AVehHookImpEntry {
            pub startAddress: u64,
            pub endAddress: u64,
            pub impl_: *mut root::PLH::AVehHook,
            pub type_: root::PLH::AVehHookImpType,
        }
        pub type eException = root::PLH::EventDispatcher;
        #[repr(C)]
        #[derive(Debug)]
        pub struct AVehHook {
            pub _base: root::PLH::IHook,
        }
        extern "C" {
            #[link_name = "\u{1}?m_refCount@AVehHook@PLH@@1VRefCounter@2@A"]
            pub static mut AVehHook_m_refCount: root::PLH::RefCounter;
        }
        extern "C" {
            #[link_name = "\u{1}?m_hHandler@AVehHook@PLH@@1PEAXEA"]
            pub static mut AVehHook_m_hHandler: *mut cty::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?m_impls@AVehHook@PLH@@1V?$unordered_set@UAVehHookImpEntry@PLH@@U?$hash@UAVehHookImpEntry@PLH@@@std@@U?$equal_to@UAVehHookImpEntry@PLH@@@4@V?$allocator@UAVehHookImpEntry@PLH@@@4@@std@@A"]
            pub static mut AVehHook_m_impls: [u64; 8usize];
        }
        extern "C" {
            #[link_name = "\u{1}?m_onException@AVehHook@PLH@@1V?$EventDispatcher@$$A6A_NPEAU_EXCEPTION_POINTERS@@PEAK@Z@2@A"]
            pub static mut AVehHook_m_onException: root::PLH::eException;
        }
        extern "C" {
            #[link_name = "\u{1}?m_onUnhandledException@AVehHook@PLH@@1V?$EventDispatcher@$$A6A_NPEAU_EXCEPTION_POINTERS@@PEAK@Z@2@A"]
            pub static mut AVehHook_m_onUnhandledException: root::PLH::eException;
        }
        extern "C" {
            #[doc = "If true is returned"]
            #[link_name = "\u{1}?EventException@AVehHook@PLH@@SAAEAV?$EventDispatcher@$$A6A_NPEAU_EXCEPTION_POINTERS@@PEAK@Z@2@XZ"]
            pub fn AVehHook_EventException() -> *mut root::PLH::eException;
        }
        extern "C" {
            #[link_name = "\u{1}?EventUnhandledException@AVehHook@PLH@@SAAEAV?$EventDispatcher@$$A6A_NPEAU_EXCEPTION_POINTERS@@PEAK@Z@2@XZ"]
            pub fn AVehHook_EventUnhandledException() -> *mut root::PLH::eException;
        }
        extern "C" {
            #[link_name = "\u{1}?Handler@AVehHook@PLH@@KAJPEAU_EXCEPTION_POINTERS@@@Z"]
            pub fn AVehHook_Handler(ExceptionInfo: *mut root::EXCEPTION_POINTERS) -> root::LONG;
        }
        extern "C" {
            #[link_name = "\u{1}??0AVehHook@PLH@@QEAA@XZ"]
            pub fn AVehHook_AVehHook(this: *mut root::PLH::AVehHook);
        }
        impl AVehHook {
            #[inline]
            pub unsafe fn EventException() -> *mut root::PLH::eException {
                AVehHook_EventException()
            }
            #[inline]
            pub unsafe fn EventUnhandledException() -> *mut root::PLH::eException {
                AVehHook_EventUnhandledException()
            }
            #[inline]
            pub unsafe fn Handler(ExceptionInfo: *mut root::EXCEPTION_POINTERS) -> root::LONG {
                AVehHook_Handler(ExceptionInfo)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                AVehHook_AVehHook(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DAVehHook@PLH@@QEAAXXZ"]
            pub fn AVehHook_AVehHook_destructor(this: *mut root::PLH::AVehHook);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct BreakPointHook {
            pub _base: root::PLH::AVehHook,
            pub m_fnCallback: u64,
            pub m_fnAddress: u64,
            pub m_origByte: u8,
        }
        extern "C" {
            #[link_name = "\u{1}??0BreakPointHook@PLH@@QEAA@_K0@Z"]
            pub fn BreakPointHook_BreakPointHook(
                this: *mut root::PLH::BreakPointHook,
                fnAddress: u64,
                fnCallback: u64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0BreakPointHook@PLH@@QEAA@PEBD0@Z"]
            pub fn BreakPointHook_BreakPointHook1(
                this: *mut root::PLH::BreakPointHook,
                fnAddress: *const cty::c_char,
                fnCallback: *const cty::c_char,
            );
        }
        impl BreakPointHook {
            #[inline]
            pub unsafe fn new(fnAddress: u64, fnCallback: u64) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                BreakPointHook_BreakPointHook(__bindgen_tmp.as_mut_ptr(), fnAddress, fnCallback);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                fnAddress: *const cty::c_char,
                fnCallback: *const cty::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                BreakPointHook_BreakPointHook1(__bindgen_tmp.as_mut_ptr(), fnAddress, fnCallback);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}?hook@BreakPointHook@PLH@@UEAA_NXZ"]
            pub fn BreakPointHook_hook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unHook@BreakPointHook@PLH@@UEAA_NXZ"]
            pub fn BreakPointHook_unHook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?OnException@BreakPointHook@PLH@@MEAAJPEAU_EXCEPTION_POINTERS@@@Z"]
            pub fn BreakPointHook_OnException(
                this: *mut cty::c_void,
                ExceptionInfo: *mut root::EXCEPTION_POINTERS,
            ) -> root::LONG;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct HWBreakPointHook {
            pub _base: root::PLH::AVehHook,
            pub m_fnCallback: u64,
            pub m_fnAddress: u64,
            pub m_regIdx: u8,
            pub m_hThread: root::HANDLE,
        }
        extern "C" {
            #[link_name = "\u{1}??0HWBreakPointHook@PLH@@QEAA@_K0PEAX@Z"]
            pub fn HWBreakPointHook_HWBreakPointHook(
                this: *mut root::PLH::HWBreakPointHook,
                fnAddress: u64,
                fnCallback: u64,
                hThread: root::HANDLE,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0HWBreakPointHook@PLH@@QEAA@PEBD0PEAX@Z"]
            pub fn HWBreakPointHook_HWBreakPointHook1(
                this: *mut root::PLH::HWBreakPointHook,
                fnAddress: *const cty::c_char,
                fnCallback: *const cty::c_char,
                hThread: root::HANDLE,
            );
        }
        impl HWBreakPointHook {
            #[inline]
            pub unsafe fn new(fnAddress: u64, fnCallback: u64, hThread: root::HANDLE) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                HWBreakPointHook_HWBreakPointHook(
                    __bindgen_tmp.as_mut_ptr(),
                    fnAddress,
                    fnCallback,
                    hThread,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                fnAddress: *const cty::c_char,
                fnCallback: *const cty::c_char,
                hThread: root::HANDLE,
            ) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                HWBreakPointHook_HWBreakPointHook1(
                    __bindgen_tmp.as_mut_ptr(),
                    fnAddress,
                    fnCallback,
                    hThread,
                );
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}?hook@HWBreakPointHook@PLH@@UEAA_NXZ"]
            pub fn HWBreakPointHook_hook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unHook@HWBreakPointHook@PLH@@UEAA_NXZ"]
            pub fn HWBreakPointHook_unHook(this: *mut cty::c_void) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?OnException@HWBreakPointHook@PLH@@MEAAJPEAU_EXCEPTION_POINTERS@@@Z"]
            pub fn HWBreakPointHook_OnException(
                this: *mut cty::c_void,
                ExceptionInfo: *mut root::EXCEPTION_POINTERS,
            ) -> root::LONG;
        }
    }
    pub type ALLOC_HANDLE = *mut cty::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ALLOC_Block {
        pub pNext: *mut cty::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ALLOC_Allocator {
        pub name: *const cty::c_char,
        pub pPool: *const cty::c_char,
        pub objectSize: usize,
        pub blockSize: usize,
        pub maxBlocks: u32,
        pub pHead: *mut root::ALLOC_Block,
        pub poolIndex: u16,
        pub blocksInUse: u16,
        pub maxBlocksInUse: u16,
        pub allocations: u16,
        pub deallocations: u16,
    }
    pub type DWORD = cty::c_ulong;
    pub type BYTE = cty::c_uchar;
    pub type WORD = cty::c_ushort;
    pub type ULONG_PTR = cty::c_ulonglong;
    pub type DWORD64 = cty::c_ulonglong;
    pub type PVOID = *mut cty::c_void;
    pub type LONG = cty::c_long;
    pub type HANDLE = *mut cty::c_void;
    pub type LONGLONG = cty::c_longlong;
    pub type ULONGLONG = cty::c_ulonglong;
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct _M128A {
        pub Low: root::ULONGLONG,
        pub High: root::LONGLONG,
    }
    pub type M128A = root::_M128A;
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct _XSAVE_FORMAT {
        pub ControlWord: root::WORD,
        pub StatusWord: root::WORD,
        pub TagWord: root::BYTE,
        pub Reserved1: root::BYTE,
        pub ErrorOpcode: root::WORD,
        pub ErrorOffset: root::DWORD,
        pub ErrorSelector: root::WORD,
        pub Reserved2: root::WORD,
        pub DataOffset: root::DWORD,
        pub DataSelector: root::WORD,
        pub Reserved3: root::WORD,
        pub MxCsr: root::DWORD,
        pub MxCsr_Mask: root::DWORD,
        pub FloatRegisters: [root::M128A; 8usize],
        pub XmmRegisters: [root::M128A; 16usize],
        pub Reserved4: [root::BYTE; 96usize],
    }
    pub type XSAVE_FORMAT = root::_XSAVE_FORMAT;
    pub type XMM_SAVE_AREA32 = root::XSAVE_FORMAT;
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub struct _CONTEXT {
        pub P1Home: root::DWORD64,
        pub P2Home: root::DWORD64,
        pub P3Home: root::DWORD64,
        pub P4Home: root::DWORD64,
        pub P5Home: root::DWORD64,
        pub P6Home: root::DWORD64,
        pub ContextFlags: root::DWORD,
        pub MxCsr: root::DWORD,
        pub SegCs: root::WORD,
        pub SegDs: root::WORD,
        pub SegEs: root::WORD,
        pub SegFs: root::WORD,
        pub SegGs: root::WORD,
        pub SegSs: root::WORD,
        pub EFlags: root::DWORD,
        pub Dr0: root::DWORD64,
        pub Dr1: root::DWORD64,
        pub Dr2: root::DWORD64,
        pub Dr3: root::DWORD64,
        pub Dr6: root::DWORD64,
        pub Dr7: root::DWORD64,
        pub Rax: root::DWORD64,
        pub Rcx: root::DWORD64,
        pub Rdx: root::DWORD64,
        pub Rbx: root::DWORD64,
        pub Rsp: root::DWORD64,
        pub Rbp: root::DWORD64,
        pub Rsi: root::DWORD64,
        pub Rdi: root::DWORD64,
        pub R8: root::DWORD64,
        pub R9: root::DWORD64,
        pub R10: root::DWORD64,
        pub R11: root::DWORD64,
        pub R12: root::DWORD64,
        pub R13: root::DWORD64,
        pub R14: root::DWORD64,
        pub R15: root::DWORD64,
        pub Rip: root::DWORD64,
        pub __bindgen_anon_1: root::_CONTEXT__bindgen_ty_1,
        pub VectorRegister: [root::M128A; 26usize],
        pub VectorControl: root::DWORD64,
        pub DebugControl: root::DWORD64,
        pub LastBranchToRip: root::DWORD64,
        pub LastBranchFromRip: root::DWORD64,
        pub LastExceptionToRip: root::DWORD64,
        pub LastExceptionFromRip: root::DWORD64,
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub union _CONTEXT__bindgen_ty_1 {
        pub FltSave: root::XMM_SAVE_AREA32,
        pub __bindgen_anon_1: root::_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
        pub Header: [root::M128A; 2usize],
        pub Legacy: [root::M128A; 8usize],
        pub Xmm0: root::M128A,
        pub Xmm1: root::M128A,
        pub Xmm2: root::M128A,
        pub Xmm3: root::M128A,
        pub Xmm4: root::M128A,
        pub Xmm5: root::M128A,
        pub Xmm6: root::M128A,
        pub Xmm7: root::M128A,
        pub Xmm8: root::M128A,
        pub Xmm9: root::M128A,
        pub Xmm10: root::M128A,
        pub Xmm11: root::M128A,
        pub Xmm12: root::M128A,
        pub Xmm13: root::M128A,
        pub Xmm14: root::M128A,
        pub Xmm15: root::M128A,
    }
    pub type PCONTEXT = *mut root::_CONTEXT;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _EXCEPTION_RECORD {
        pub ExceptionCode: root::DWORD,
        pub ExceptionFlags: root::DWORD,
        pub ExceptionRecord: *mut root::_EXCEPTION_RECORD,
        pub ExceptionAddress: root::PVOID,
        pub NumberParameters: root::DWORD,
        pub ExceptionInformation: [root::ULONG_PTR; 15usize],
    }
    pub type EXCEPTION_RECORD = root::_EXCEPTION_RECORD;
    pub type PEXCEPTION_RECORD = *mut root::EXCEPTION_RECORD;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _EXCEPTION_POINTERS {
        pub ExceptionRecord: root::PEXCEPTION_RECORD,
        pub ContextRecord: root::PCONTEXT,
    }
    pub type EXCEPTION_POINTERS = root::_EXCEPTION_POINTERS;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_20 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_21 {
        pub _address: u8,
    }
}
